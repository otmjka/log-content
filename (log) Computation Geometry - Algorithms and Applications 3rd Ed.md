	# Computation Geometry


Представьте, что вы идете по кампусу университета и вдруг понимаете, что вам нужно срочно позвонить. На кампусе много общественных телефонов, и, конечно, вы хотите пойти к ближайшему из них. Но какой из них ближайший? Было бы полезно иметь карту, на которой вы могли бы найти ближайший общественный телефон, где бы вы ни находились на кампусе. Карта должна показывать разделение кампуса на регионы, и для каждого региона указывать ближайший общественный телефон. Как будут выглядеть эти регионы? И как мы можем их вычислить?


![[Pasted image 20241210115836.png]]


Хотя это не такой уж важный вопрос, он описывает основы
фундаментальной геометрической концепции, которая играет роль во многих приложениях.

Разделение кампуса — это так называемая диаграмма Вороного, и она будет изучена в главе 7 этой книги. Ее можно использовать для моделирования торговых зон различных городов, для управления роботами и даже для описания и моделирования роста кристаллов. Вычисление геометрической структуры, такой как диаграмма Вороного, требует геометрических алгоритмов. Такие алгоритмы и являются темой этой книги.

Второй пример. Предположим, вы нашли ближайший общественный телефон. Имея на руках карту кампуса, вы, вероятно, без труда доберетесь до телефона по достаточно короткому пути, не задевая стены и другие объекты.

Но программирование робота для выполнения той же задачи намного сложнее. Опять же, суть проблемы геометрическая: учитывая набор геометрических препятствий, мы должны найти короткое соединение между двумя точками, избегая столкновений с препятствиями. Решение этой так называемой проблемы планирования движения имеет решающее значение в робототехнике. Главы 13 и 15 посвящены геометрическим алгоритмам, необходимым для планирования движения.

Третий пример. Предположим, у вас не одна карта, а две: одна с описанием различных зданий, включая общественные телефоны, и одна с указанием дорог на территории кампуса. Чтобы спланировать движение к общественному телефону, нам нужно наложить эти карты, то есть объединить информацию на двух картах. Наложение карт является одной из основных операций географических информационных систем. Оно включает в себя определение положения объектов с одной карты на другой, вычисление пересечения различных объектов и т. д. Глава 2 рассматривает эту проблему.

Это всего лишь три примера геометрических задач, требующих тщательно разработанных геометрических алгоритмов для их решения. В 1970-х годах возникла область вычислительной геометрии, занимающаяся такими геометрическими задачами. Ее можно определить как систематическое изучение алгоритмов и структур данных для геометрических объектов с акцентом на точные алгоритмы, которые являются асимптотически быстрыми. Многих исследователей привлекали проблемы, поставленные геометрическими задачами. Дорога от формулировки задачи до эффективных и элегантных решений часто была долгой, со множеством сложных и неоптимальных промежуточных результатов. Сегодня существует богатая коллекция геометрических алгоритмов, которые эффективны и относительно просты для понимания и реализации.

В этой книге описываются наиболее важные понятия, методы, алгоритмы и структуры данных вычислительной геометрии таким образом, что, как мы надеемся, это будет интересно читателям, которые заинтересованы в применении результатов вычислительной геометрии. Каждая глава мотивирована реальной вычислительной задачей, требующей геометрических алгоритмов для своего решения. Чтобы показать широкую применимость вычислительной геометрии, задачи были взяты из различных прикладных областей: робототехники, компьютерной графики, CAD/CAM и географических информационных систем.

Не стоит ожидать готовых к внедрению программных решений для основных проблем в прикладных областях. Каждая глава посвящена одной концепции вычислительной геометрии; приложения служат только для введения и мотивации концепций. Они также иллюстрируют процесс моделирования инженерной проблемы и поиска точного решения.


## 1.1 An Example: Convex Hulls

Хорошие решения алгоритмических задач геометрического характера в основном основаны на двух ингредиентах. Один из них — это глубокое понимание геометрических свойств задачи, другой — правильное применение алгоритмических методов и структур данных. Если вы не понимаете геометрию задачи, все алгоритмы мира не помогут вам решить ее эффективно. С другой стороны, даже если вы прекрасно понимаете геометрию задачи, ее трудно решить эффективно, если вы не знаете правильных алгоритмических методов. Эта книга даст вам глубокое понимание важнейших геометрических концепций и алгоритмических методов.

Чтобы проиллюстрировать проблемы, возникающие при разработке геометрического алгоритма, в этом разделе рассматривается одна из первых проблем, которая изучалась в вычислительной геометрии: вычисление плоских выпуклых оболочек. Мы пропустим мотивацию этой проблемы здесь; если вам интересно, вы можете прочитать введение к главе 11, где мы изучаем выпуклые оболочки в трехмерном пространстве.

Подмножество $S$ плоскости называется `выпуклым` тогда и только тогда, когда для любой пары точек $\vec{p,q} ∈ S$ отрезок $\vec{pq}$ полностью содержится в $S$. 

`Выпуклая оболочка` $CH(S)$ множества $S$ — это наименьшее выпуклое множество, содержащее $S$. Точнее, это пересечение всех выпуклых множеств, содержащих $S$.
![[Pasted image 20241210165643.png]]
```
1. **Выпуклое множество:**
• Подмножество считается выпуклым, если любой отрезок, соединяющий две точки внутри этого множества, также полностью находится внутри него.
• Например, круг или треугольник — выпуклые, а форма с “выемками” — не выпуклая.
2. **Выпуклая оболочка:**
• Если у вас есть произвольное множество точек, их выпуклая оболочка — это минимальное выпуклое множество, которое полностью их охватывает.
• Чтобы её построить, можно представить “натянутую резинку” вокруг всех точек.
```

Мы изучим задачу вычисления выпуклой оболочки конечного множества $P$ из n точек на плоскости.Мы можем представить себе, как выглядит выпуклая оболочка, с помощью мысленного эксперимента.Представьте, что точки — это гвозди, торчащие из плоскости, возьмите эластичную резинку, обмотайте ею гвозди и отпустите. Она защелкнется вокруг гвоздей, уменьшив свою длину. Область, ограниченная резинкой, является выпуклой оболочкой $P$. Это приводит к альтернативному определению выпуклой оболочки конечного множества $P$ точек на плоскости: это единственный выпуклый многоугольник, вершинами которого являются точки из $P$ и который содержит все точки $P$. Конечно, мы должны строго доказать, что это определение корректно, то есть что многоугольник уникален, и что это определение эквивалентно предыдущему, но давайте пропустим это в этой вводной главе.

Как вычислить выпуклую оболочку? Прежде чем ответить на этот вопрос, нужно задать другой: что означает “вычислить выпуклую оболочку”? Как мы уже видели, выпуклая оболочка множества $P$ — это выпуклый многоугольник. Естественный способ представления многоугольника — `это перечисление его вершин в порядке по часовой стрелке`, начиная с произвольной вершины. 

Таким образом, задача, которую мы хотим решить, выглядит так: 
задано множество точек на плоскости 
$$P= \{p_1, p_2, ... , p_n\}$$
нужно вычислить список, который содержит те точки из , которые являются вершинами выпуклой оболочки $CH(P)$, перечисленные в порядке по часовой стрелке.

![[Pasted image 20241210131458.png]]

Первая дефиниция выпуклой оболочки мало помогает, когда нужно разработать алгоритм для её вычисления. Она говорит о пересечении всех выпуклых множеств, содержащих $P$, а таких множеств бесконечно много. Намного полезнее наблюдение, что выпуклая оболочка $CH(P)$— это выпуклый многоугольник. Давайте рассмотрим, какие `рёбра(edges)` $CH(P)$ у этой оболочки. Оба конца ребра $p$ и $q$ являются точками из $P$, и если направить прямую через $p$ и $q$ так, чтобы выпуклая оболочка $CH(P)$ находилась справа от неё, то все точки из $P$  должны находиться справа от этой прямой. 

Обратное тоже верно: 
если все точки $P$ \ $\{p,q\}$ из находятся справа от направленной прямой через $p$ и $q$ , то отрезок $\vec{pq}$ является рёбром $CH(P)$.

Теперь, когда мы немного лучше понимаем геометрию задачи, можно разработать алгоритм. Мы опишем его в стиле псевдокода, который будем использовать в этой книге.

![[Pasted image 20241210175004.png]]
![[Pasted image 20241210135020.png]]
  

  Из множества рёбер строим список вершин выпуклой оболочки , отсортированный по часовой стрелке.
```
**Пояснение шагов:**
**Шаг 5: Тестирование на “лежащее слева” или “справа” относительно направленной прямой**
Чтобы проверить, лежит ли точка слева или справа от направленной прямой через и , используется операция, которая основывается на вычислении ориентации тройки точек (векторного произведения). Это является примитивной операцией в геометрических алгоритмах и может быть выполнено за .
2. **Шаги по построению списка вершин выпуклой оболочки**
• Мы начинаем с произвольного ребра из множества рёбер , помещаем его начало в список , а конец как вторую точку.
• Затем мы последовательно находим рёбра, чье начало совпадает с текущей конечной точкой, и добавляем их в список, пока не обработаем все рёбра. Это позволяет восстановить вершины оболочки в порядке по часовой стрелке.
**Оценка сложности:**
1. Для каждой пары точек проверяется, находятся ли все другие точки с правой стороны от направленной прямой. Это даёт время , так как для каждой из пар проверяются точек.
2. Построение списка вершин оболочки из рёбер требует времени .
Итак, общая сложность алгоритма — , что слишком медленно для практического использования при больших входных данных.
```

Два шага в алгоритме, возможно, не совсем ясны.

Первый — это строка 5: как проверить, лежит ли точка слева или справа от направленной прямой? Это одна из примитивных операций, необходимых в большинстве геометрических алгоритмов. В рамках этой книги мы предполагаем, что такие операции доступны. Очевидно, что они могут выполняться за постоянное время, поэтому их реализация не повлияет на асимптотическое время работы алгоритма. Однако это не значит, что такие операции тривиальны или неважны. Их сложно правильно реализовать, и от этого зависит фактическое время работы алгоритма. К счастью, в настоящее время существуют программные библиотеки, содержащие такие примитивные операции. Таким образом, мы можем считать, что проверка в строке 5 выполняется с использованием готовой функции за постоянное время.

  Другой шаг, который требует пояснения, — это последний шаг алгоритма. В цикле строк 2–7 мы определяем множество $E$ , содержащее рёбра выпуклой оболочки. Из $E$ можно построить список $L$ следующим образом. Рёбра в $E$  направлены, поэтому у каждого ребра есть начальная и конечная точки. Поскольку рёбра направлены так, что остальные точки лежат справа, конечная точка ребра следует за его начальной точкой, если вершины упорядочены по часовой стрелке. Теперь удаляем произвольное ребро $\vec{e_1}$ из $E$. Помещаем начальную точку $\vec{e_1}$ как первую в список $L$ , а конечную точку — как вторую. Затем находим ребро $\vec{e_2}$ в $E$, начальная точка которого совпадает с конечной точкой $\vec{e_1}$, удаляем его из $E$ и добавляем его конечную точку  в $L$ . Далее находим ребро $\vec{e_3}$, начальная точка которого совпадает с конечной точкой $\vec{e_2}$, удаляем его из $E$ и добавляем его конечную точку в $L$. Продолжаем в том же духе, пока в не останется только одно ребро в $E$. На этом этапе конечная точка оставшегося ребра обязательно будет начальной точкой $\vec{e_1}$, которая уже находится в списке $L$. Простая реализация этой процедуры занимает $O(n^2)$ времени. Это можно легко улучшить до $O(n\log n)$, но время, затрачиваемое на остальные шаги алгоритма, всё равно доминирует в общем времени выполнения.

Анализировать временную сложность алгоритма **SLOWCONVEXHULL** просто. Мы проверяем $n^2 -n$ пар точек. Для каждой пары мы рассматриваем $n - 2$ других точек, чтобы убедиться, что все они лежат справа. Это занимает в общей сложности $O(n^3)$. Последний шаг занимает $O(n^2)$, так что общее время выполнения — $O(n^3)$. Алгоритм с кубической сложностью слишком медленный, чтобы быть полезным на практике, кроме как для самых маленьких наборов данных. Проблема в том, что мы не использовали никаких эффективных алгоритмических техник, а просто перевели геометрическую идею в алгоритм методом полного перебора. Однако прежде чем пытаться улучшить его, полезно сделать несколько наблюдений об этом алгоритме.

![[Pasted image 20241210180816.png]]

Мы были несколько небрежны при выводе критерия, по которому пара $p, q$ точек определяет ребро $\mathcal{CH}(P)$ . Точка $r$ не всегда лежит строго справа или слева от прямой, проходящей через и $p;q$ может случиться, что она находится на этой прямой. Что же делать в таком случае? Это то, что называется вырожденным случаем (или просто вырождением). Мы предпочитаем игнорировать такие ситуации при первоначальном рассмотрении задачи, чтобы не запутаться при анализе её геометрических свойств. Однако такие ситуации действительно возникают на практике. Например, если точки создаются путём щелчков мышью по экрану, то все точки будут иметь небольшие целочисленные координаты, и вполне вероятно, что три точки окажутся на одной прямой.

Чтобы алгоритм оставался корректным в присутствии вырождений, нам нужно переформулировать критерий следующим образом: направленное ребро $\vec{pq}$ является ребром $\mathcal{CH}(P)$, если и только если все $r \in P$ остальные точки либо строго лежат справа от направленной прямой, проходящей через $p$ и $q$, либо лежат на открытом отрезке $pq$. (Мы предполагаем, что в  $P$ нет совпадающих точек.) Таким образом, строку 5 алгоритма необходимо заменить на этот более сложный тест.
![[Pasted image 20241210183224.png]]
Мы также игнорировали другую важную проблему, которая может повлиять на корректность результата алгоритма. Мы неявно предположили, что можем точно проверять, лежит ли точка справа или слева от данной прямой. Это не всегда так: если координаты точек заданы в виде чисел с плавающей запятой, а вычисления выполняются с использованием арифметики с плавающей запятой, то ошибки округления могут исказить результат тестов.

Представьте, что есть три точки $p, q$ и $r$, которые почти [коллинеарны](obsidian://open?vault=log-content&file=%D0%BA%D0%BE%D0%BB%D0%BB%D0%B8%D0%BD%D0%B5%D0%B0%D1%80%D0%BD%D1%8B%D0%B5), и все остальные точки лежат далеко справа от них. Алгоритм проверяет пары $(p, q)$,$(r, q)$ и $(q, r)$. Поскольку эти точки почти лежат на одной прямой, ошибки округления могут привести к решению, что $r$ лежит справа от прямой, проходящей через $p$ и $q$ , что лежит справа от прямой, проходящей через $r$ и $q$, и что $q$ лежит справа от прямой, проходящей через $p$ и $r$. Конечно, геометрически это невозможно, но арифметика с плавающей запятой этого не знает! В этом случае алгоритм примет все три ребра. Ещё хуже, если все три теста дадут противоположный результат, тогда алгоритм отклонит все три ребра, что приведёт к разрыву границы выпуклой оболочки. Это вызывает серьёзную проблему при попытке построить упорядоченный список вершин выпуклой оболочки на последнем шаге алгоритма. Этот шаг предполагает, что в каждой вершине выпуклой оболочки начинается ровно одно ребро и заканчивается ровно одно ребро. Из-за ошибок округления внезапно может оказаться, что в вершине начинается либо два, либо ни одного ребра $p$. Это может привести к сбою программы, реализующей наш простой алгоритм, поскольку последний шаг не был разработан для работы с такими несогласованными данными.

| ![[Pasted image 20241210183334.png]] | ![[Pasted image 20241210183350.png]] |
| ------------------------------------ | ------------------------------------ |
|                                      |                                      |

Хотя мы доказали корректность алгоритма и его способность обрабатывать все особые случаи, он не является надёжным: небольшие ошибки в вычислениях могут привести к сбою совершенно неожиданным образом. Проблема в том, что мы доказали корректность, предполагая, что можем вычислять с абсолютной точностью, используя действительные числа.

Мы разработали наш первый геометрический алгоритм. Он вычисляет выпуклую оболочку множества точек на плоскости. Однако он довольно медленный (его время выполнения — $O(n^3)$ ), неудобно обрабатывает вырожденные случаи и не является надёжным. Нам стоит попытаться сделать лучше.

Для достижения этой цели мы применяем стандартный метод алгоритмического проектирования: разработаем инкрементальный алгоритм. Это означает, что мы будем добавлять точки в $P$ одну за другой, обновляя решение после каждого добавления. Мы придадим этому подходу геометрический характер, добавляя точки слева направо. Таким образом, сначала сортируем точки по их x-координатам, получая упорядоченную последовательность $p_1, ..., p_n$ , а затем добавляем их в этом порядке. Поскольку мы движемся слева направо, было бы удобно, если бы вершины `выпуклой оболочки` также были упорядочены слева направо вдоль её границы. Однако это не так. Поэтому мы сначала вычисляем только те вершины выпуклой оболочки, которые лежат на `верхней оболочке(upper hull)` — это часть выпуклой оболочки, проходящая от самой левой точки $p_1$ до самой правой точки $p_n$, если вершины перечислены в порядке по часовой стрелке. Другими словами, верхняя оболочка содержит рёбра выпуклой оболочки, ограничивающие её сверху. На втором этапе, выполняемом справа налево, мы вычисляем оставшуюся часть выпуклой оболочки — нижнюю оболочку.
![[Pasted image 20241210185531.png]]
  

Основной шаг инкрементального алгоритма — это обновление верхней оболочки после добавления точки $p_i$. Иными словами, зная верхнюю оболочку для точек $p_1, ..., p_i-1$, мы должны вычислить верхнюю оболочку для точек $p_1, ..., p_i$ . Это можно сделать следующим образом. Если мы обходим границу многоугольника по часовой стрелке, то на каждой вершине совершается поворот. Для произвольного многоугольника это может быть как правый, так и левый поворот, но для выпуклого многоугольника каждый поворот должен быть правым. Это подсказывает следующий способ обработки добавления точки $p_i$. Пусть $\mathcal{L_upper}$ — это список, который хранит вершины верхней оболочки в порядке слева направо. Сначала добавляем $p_i$ в  $\mathcal{L_upper}$. Это корректно, так как $p_i$ — самая правая из добавленных точек, и она должна находиться на верхней оболочке. Затем проверяем, образуют ли последние три точки в  $\mathcal{L_upper}$ правый поворот. Если это так, то ничего больше делать не нужно; $\mathcal{L_upper}$ содержит вершины верхней оболочки для $p_1, ..., p_i$, и можно переходить к следующей точке $p_i+1$ . Но если последние три точки образуют левый поворот, мы удаляем среднюю из них из верхней оболочки. В этом случае процесс не завершён: возможно, новые последние три точки всё ещё не образуют правый поворот, и тогда нужно снова удалить среднюю из них. Мы продолжаем этот процесс до тех пор, пока последние три точки не образуют правый поворот, либо пока в списке не останется только две точки.

Ниже приведён алгоритм в виде псевдокода. Он вычисляет как верхнюю, так и нижнюю оболочки. Последняя вычисляется путём обработки точек справа налево, аналогично вычислению верхней оболочки.
![[Pasted image 20241210220220.png]]
![[Pasted image 20241210220237.png]]

Снова, при более внимательном рассмотрении, мы понимаем, что приведённый выше алгоритм некорректен. Неявно мы предположили, что никакие две точки не имеют одинаковую x-координату. Если это предположение неверно, порядок по x-координате становится плохо определённым. К счастью, это не является серьёзной проблемой. Нужно лишь обобщить порядок подходящим образом: вместо использования только x-координаты для определения порядка, мы используем лексикографический порядок. Это означает, что мы сначала сортируем точки по x-координате, а если точки имеют одинаковую x-координату, то сортируем их по y-координате.

Другой особый случай, который мы игнорировали, — это ситуация, когда три точки, для которых мы должны определить, образуют ли они левый или правый поворот, лежат на одной прямой. В этом случае средняя точка не должна входить в выпуклую оболочку, поэтому коллинеарные точки нужно обрабатывать так, как если бы они образовали левый поворот. Другими словами, нужно использовать тест, который возвращает true, если три точки образуют правый поворот, и false в противном случае. (Заметьте, что этот тест проще, чем тест, требовавшийся в предыдущем алгоритме для обработки коллинеарных точек.)

С учётом этих модификаций алгоритм корректно вычисляет выпуклую оболочку: первый проход вычисляет верхнюю оболочку, которая теперь определяется как часть выпуклой оболочки, проходящая от лексикографически наименьшей вершины до лексикографически наибольшей вершины, а второй проход вычисляет оставшуюся часть выпуклой оболочки.

Что делает наш алгоритм при наличии ошибок округления в арифметике с плавающей точкой? При таких ошибках может случиться, что точка будет удалена из выпуклой оболочки, хотя она должна там находиться, или что точка внутри реальной выпуклой оболочки не будет удалена. Но структурная целостность алгоритма остаётся неизменной: он вычислит замкнутую полигональную цепь. В конце концов, результат — это список точек, который можно интерпретировать как список вершин многоугольника в порядке по часовой стрелке, причём любые три последовательные точки образуют правый поворот или, из-за ошибок округления, почти образуют правый поворот. Более того, ни одна точка из не может находиться далеко за пределами вычисленной оболочки. Единственная проблема, которая всё же может возникнуть, заключается в том, что если три точки находятся очень близко друг к другу, поворот, который на самом деле является резким левым поворотом, может быть интерпретирован как правый. Это может привести к «вмятине» в результирующем многоугольнике. Выход из этой ситуации — убедиться, что точки во входных данных, которые находятся очень близко друг к другу, считаются одной и той же точкой, например, путём округления координат. Таким образом, хотя результат и не обязательно будет абсолютно точным — а этого и нельзя ожидать, если используется неточная арифметика — он всё же будет иметь смысл. Для многих приложений этого достаточно. Однако всё равно рекомендуется внимательно реализовывать базовый тест, чтобы минимизировать вероятность ошибок.

| ![[Pasted image 20241211084413.png]] | ![[Pasted image 20241211084405.png]] |
| ------------------------------------ | ------------------------------------ |


![[Pasted image 20241211084521.png]]

Закончим следующим теоремой:

[Теорема 1.1.] Выпуклая(convex) оболочка множества(set) из $n$ точек на плоскости может быть вычислена за время $O(n \log n)$.

Доказательство. Докажем корректность вычисления верхней оболочки; корректность вычисления нижней оболочки можно доказать аналогично.

Доказательство проводится индукцией по количеству обработанных точек. Перед началом цикла for-loop список $\mathcal{L_upper}$ содержит точки $p_1$ и $p_2$, которые тривиально образуют верхнюю оболочку множества ${p_1, p_2}$. Теперь предположим, что $\mathcal{L_upper}$ содержит вершины верхней оболочки множества ${p_1, ..., p_{i-1}}$, и рассмотрим добавление точки $p_{i}$. После выполнения цикла while-loop и в соответствии с индуктивным предположением, мы знаем, что точки в $\mathcal{L_upper}$ образуют цепь, которая делает только правые повороты. Более того, цепь начинается с лексикографически минимальной точки из множества ${p_1, ..., p_{i}}$ и заканчивается лексикографически максимальной точкой, а именно $p_{i}$. Если мы докажем, что все точки множества ${p_1, ..., p_{i}}$, которые не входят в $\mathcal{L_upper}$, находятся ниже этой цепи, то $\mathcal{L_upper}$ содержит правильные точки.

По индукции мы знаем, что нет точек выше цепи, которая существовала до добавления $p_{i}$. Так как старая цепь лежит ниже новой цепи, единственная возможность для точки оказаться выше новой цепи — это если она лежит в вертикальной полосе между $p_{i-1}$ и $p_{i}$. Но это невозможно, так как такая точка находилась бы между $p_{i-1}$ и $p_{i}$ в лексикографическом порядке. (Вы можете проверить, что аналогичный аргумент работает, если $p_{i-1}$ и $p_{i}$, или любые другие точки, имеют одинаковую $x$-координату.)

Чтобы доказать временную сложность, заметим, что сортировка точек в лексикографическом порядке выполняется за $O(n \log n)$. Теперь рассмотрим вычисление верхней оболочки. Цикл $\text{for}$ выполняется линейное число раз. Остаётся вопрос, сколько раз выполняется вложенный цикл $\text{while}$. Для каждой итерации цикла $\text{for}$ цикл $\text{while}$ выполняется хотя бы один раз. Для каждой дополнительной итерации удаляется одна точка из текущей оболочки. Так как каждая точка может быть удалена только один раз во время построения верхней оболочки, общее число дополнительных итераций цикла $\text{while}$ для всех итераций цикла $\text{for}$ ограничено $O(n)$. Аналогично, вычисление нижней оболочки занимает $O(n)$ времени. Учитывая шаг сортировки, общее время, необходимое для вычисления выпуклой оболочки, равно $O(n \log n)$.

Окончательный алгоритм построения выпуклой оболочки прост для описания и лёгок в реализации. Он требует только лексикографической сортировки и проверки, образуют ли три последовательные точки правый поворот. Исходя из первоначального определения задачи, было далеко не очевидно, что такая простая и эффективная реализация возможна.

**1.2 Вырождения и устойчивость**

Как мы видели в предыдущем разделе, разработка геометрического алгоритма часто проходит через три фазы.

В **первой фазе** мы стараемся игнорировать всё, что может затруднить наше понимание геометрических концепций, с которыми мы работаем. Иногда неудобны коллинеарные точки, иногда — вертикальные отрезки. На этапе проектирования или изучения алгоритма часто полезно не учитывать такие вырожденные случаи.

Во **второй фазе** необходимо скорректировать алгоритм, спроектированный на первом этапе, чтобы он работал корректно в присутствии вырожденных случаев. Новички склонны добавлять множество разветвлений в код, чтобы учесть все возможные исключения. Однако часто можно найти лучший подход. Переосмыслив геометрию задачи, можно интегрировать особые случаи в общий алгоритм. Например, в алгоритме вычисления выпуклой оболочки вместо сортировки только по -координате мы использовали лексикографический порядок, чтобы корректно обрабатывать точки с одинаковой -координатой. Для большинства алгоритмов в этой книге мы пытались использовать такой интегрированный подход. Тем не менее, на этапе изучения алгоритма проще не задумываться о вырожденных случаях. После того как общий случай станет понятен, можно возвращаться к учёту исключений.

Если вы изучаете литературу по вычислительной геометрии, то заметите, что многие авторы игнорируют вырожденные случаи, формулируя специфические предположения о входных данных. Например, в задаче о выпуклой оболочке можно было бы заявить, что входные данные не содержат трёх коллинеарных точек или точек с одинаковыми -координатами. Теоретически такие предположения оправданы: цель состоит в определении вычислительной сложности задачи, а вырожденные случаи почти всегда можно обработать без увеличения асимптотической сложности алгоритма. Однако они значительно усложняют реализацию. Сегодня большинство исследователей понимают, что их предположения о “общем положении” точек редко соблюдаются на практике, и интеграция вырожденных случаев — лучший подход. Кроме того, существуют общие методы, такие как символические схемы возмущений, которые позволяют игнорировать особые случаи при разработке и реализации, сохраняя корректность алгоритма в присутствии вырождений.

**Третья фаза** — это реализация. На этом этапе важно учитывать примитивные операции, например, проверку того, лежит ли точка слева, справа или на направленной прямой. Если вам повезёт, и вы имеете доступ к библиотеке геометрического ПО, содержащей необходимые операции, то задача упрощается. В противном случае придётся реализовать их самостоятельно.

Ещё одной проблемой на этапе реализации становится отказ предположения о точной арифметике с вещественными числами. Это требует понимания последствий. Проблемы устойчивости часто вызывают разочарование при реализации геометрических алгоритмов. Решение этих проблем не всегда просто. Один из вариантов — использовать пакеты для точной арифметики (с использованием целых, рациональных или даже алгебраических чисел, в зависимости от задачи), но это медленно. Другой подход — адаптировать алгоритм для обнаружения несоответствий и предпринимать действия, чтобы избежать аварийного завершения программы. В этом случае результат алгоритма может быть некорректным, поэтому важно определить точные свойства результата. Именно это мы сделали в предыдущем разделе: выпуклый полигон мог быть некорректным, но его структура остаётся правильной, и он близок к истинной выпуклой оболочке. Также можно предсказать точность числового представления, необходимую для корректного решения задачи.

Какой подход лучше, зависит от приложения. Если скорость не критична, предпочтительна точная арифметика. В других случаях точность результата не так важна. Например, при отображении выпуклой оболочки множества точек небольшие отклонения полигона от истинной оболочки, скорее всего, будут незаметны. В таких случаях можно использовать аккуратную реализацию на основе арифметики с плавающей запятой.

**1.3 Области применения**

Как уже упоминалось, для каждого геометрического концепта, алгоритма или структуры данных, представленных в этой книге, мы выбрали пример приложения для мотивации. Большинство приложений относятся к областям компьютерной графики, робототехники, географических информационных систем (ГИС) и CAD/CAM. Для тех, кто не знаком с этими направлениями, приведём краткое описание этих областей и укажем некоторые геометрические задачи, возникающие в них.

**Компьютерная графика**
Компьютерная графика занимается созданием изображений смоделированных сцен для отображения на экране компьютера, принтере или других устройствах вывода. Сцены могут варьироваться от простых двумерных рисунков, состоящих из линий, полигонов и других примитивных объектов, до реалистичных трёхмерных сцен, включающих источники света, текстуры и т. д. Сцены последнего типа могут легко содержать более миллиона полигонов или участков криволинейных поверхностей.

Поскольку сцены состоят из геометрических объектов, геометрические алгоритмы играют важную роль в компьютерной графике.

Для двумерной графики типичными задачами являются:
• определение пересечения примитивов,
• определение примитива, на который указывает мышь,
• нахождение подмножества примитивов, находящихся в заданной области.

Методы, полезные для решения этих задач, рассматриваются в главах 6, 10 и 16.

При работе с трёхмерными задачами геометрические вопросы становятся сложнее. Ключевым этапом при отображении трёхмерной сцены является **устранение скрытых поверхностей**: определение видимой из заданной точки части сцены, то есть исключение частей, находящихся за другими объектами. В главе 12 мы изучаем один из подходов к этой задаче.

Для создания реалистичных сцен необходимо учитывать свет. Это порождает множество новых задач, таких как вычисление теней. Таким образом, реалистичный синтез изображений требует сложных методов отображения, таких как трассировка лучей и метод радиации.

В приложениях с движущимися объектами и в виртуальной реальности важно обнаруживать столкновения между объектами. Все эти ситуации связаны с геометрическими задачами.

| **Робототехника**                    |                                      |
| ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20241211113413.png]] | ![[Pasted image 20241211113450.png]] |

Робототехника изучает проектирование и использование роботов. Поскольку роботы являются геометрическими объектами, работающими в трёхмерном пространстве (реальном мире), геометрические задачи возникают повсюду.

В начале этой главы мы уже упоминали задачу **планирования движения**, где робот должен найти путь в среде с препятствиями. В главах 13 и 15 мы изучаем простые случаи планирования движения. Это одна из частей более общей задачи — **планирования задач**.

Идея заключается в том, чтобы задавать роботу задачи высокого уровня, например, “пропылесось комнату”, а затем дать ему возможность самостоятельно определить, как лучше выполнить задачу. Это включает в себя:
• планирование движения,
• планирование порядка выполнения подзадач и т. д.
Другие геометрические задачи возникают при проектировании роботов и рабочих ячеек, в которых они работают. Большинство промышленных роботов — это роботизированные руки с фиксированной базой. Обрабатываемые детали должны быть поданы таким образом, чтобы робот мог легко захватить их.

Некоторые детали необходимо зафиксировать, чтобы робот мог с ними работать. Также может потребоваться их предварительное ориентирование. Все эти задачи являются геометрическими, иногда с кинематической составляющей.

Некоторые алгоритмы, описанные в этой книге, применимы для решения таких задач. Например, задача о минимальном охватывающем круге, рассмотренная в разделе 4.7, может использоваться для оптимального размещения роботизированных рук.  

В оставшейся части книги мы сосредоточимся на фазе проектирования геометрических алгоритмов; о проблемах реализации будет сказано немного.


**Географические информационные системы**
Географическая информационная система (ГИС) хранит географические данные, такие как форма стран, высота гор, течение рек, тип растительности в разных местах, плотность населения или количество осадков. Она также может содержать информацию о созданных человеком объектах, например, о городах, дорогах, железных путях, линиях электропередачи или газопроводах.

ГИС используется для извлечения информации о определённых регионах и, в частности, для получения данных о взаимосвязях между разными типами информации. Например:
• Биолог может захотеть установить связь между средней величиной осадков и наличием определённых растений.
• Инженер-строитель может запросить данные в ГИС, чтобы узнать, находятся ли под определённым участком земли газовые трубы, прежде чем начать раскопки.

Поскольку большая часть географической информации касается свойств точек и областей на поверхности Земли, геометрические задачи здесь встречаются в изобилии. Более того, объёмы данных настолько велики, что использование эффективных алгоритмов становится необходимостью. Ниже приведены примеры задач ГИС, рассмотренных в этой книге.

Первая задача — как хранить географические данные. Предположим, мы хотим разработать систему навигации для автомобиля, которая показывает водителю его текущее местоположение. Для этого нужно хранить огромную карту дорог и других данных. В любой момент времени требуется определять местоположение автомобиля на карте и быстро выбирать небольшую её часть для отображения на бортовом компьютере. Для выполнения этих операций необходимы эффективные структуры данных. Глава 6, 10 и 16 описывают решения этих задач в области вычислительной геометрии.

Информация о высотах в горной местности обычно доступна только в отдельных точках выборки. Для других позиций высоту приходится определять путём интерполяции между ближайшими точками выборки. Но какие точки выборки следует выбрать? Эта задача рассматривается в главе 9.

Комбинирование различных типов данных — одна из самых важных операций в ГИС. Например:

• Мы можем захотеть определить, какие дома находятся в лесу.

• Найти все мосты, проверив, где дороги пересекаются с реками.

• Выбрать место для нового гольф-клуба, найдя слегка холмистую, сравнительно недорогую местность недалеко от определённого города.

В ГИС обычно разные типы данных хранятся в отдельных картах. Чтобы объединить данные, необходимо наложить эти карты друг на друга. Проблемы, связанные с вычислением наложения, рассматриваются в главе 2.

Наконец, упомянем пример, приведённый в начале главы: нахождение ближайшего общественного телефона (или больницы, или любого другого объекта). Это требует вычисления диаграммы Вороного — структуры, подробно изучаемой в главе 7.

**CAD/CAM**

Компьютерное проектирование (CAD, Computer-Aided Design) занимается разработкой изделий с использованием компьютера. Эти изделия могут варьироваться от печатных плат, деталей машин или мебели до целых зданий. Во всех случаях результат проектирования представляет собой геометрический объект, и поэтому вполне ожидаемо, что в процессе возникают разнообразные геометрические задачи.

Действительно, CAD-программы должны уметь работать с пересечениями и объединениями объектов, разбиением объектов и их границ на более простые формы, а также с визуализацией спроектированных изделий.

Для проверки соответствия проекта заданным спецификациям требуются определённые тесты. Часто для этого не нужно создавать физический прототип; достаточно симуляции. Глава 14 посвящена задаче, возникающей при моделировании тепловыделения на печатной плате.

После того как объект спроектирован и проверен, его необходимо изготовить. Здесь могут помочь системы автоматизированного производства (CAM, Computer-Aided Manufacturing). CAM включает множество геометрических задач, одна из которых рассматривается в главе 4.

Современная тенденция — проектирование с учётом сборки (design for assembly), где решения по сборке принимаются уже на этапе проектирования. CAD-системы, поддерживающие такой подход, позволяют проектировщикам проверять, насколько их конструкция осуществима, отвечая на вопросы вроде: можно ли легко собрать изделие с использованием определённого производственного процесса? Многие из таких вопросов требуют применения геометрических алгоритмов.
![[Pasted image 20241211113548.png]]
**Другие области применения**

Существует множество других областей, где возникают геометрические задачи, а также можно использовать геометрические алгоритмы и структуры данных для их решения.

  

Например, в молекулярном моделировании молекулы часто представляются в виде набора пересекающихся шаров в пространстве, где каждый шар соответствует атому. Типичные задачи включают вычисление объединения атомных шаров для получения поверхности молекулы или определение мест, где две молекулы могут соприкасаться.

  

Ещё одна область — распознавание образов. Рассмотрим, например, систему оптического распознавания символов. Такая система сканирует текст на бумаге с целью распознавания символов. Базовый шаг заключается в сопоставлении изображения символа с коллекцией сохранённых символов для нахождения наиболее подходящего. Это приводит к геометрической задаче: определить, насколько два геометрических объекта похожи друг на друга.

  

Даже некоторые области, которые на первый взгляд не кажутся связанными с геометрией, могут извлечь выгоду из геометрических алгоритмов, поскольку часто возможно сформулировать негeометрические задачи в геометрических терминах. Например, в главе 5 мы увидим, как записи в базе данных можно интерпретировать как точки в многомерном пространстве, а также представим геометрическую структуру данных, которая позволяет эффективно отвечать на определённые запросы к этим записям.

  

Мы надеемся, что приведённая выше коллекция геометрических задач ясно показывает, что вычислительная геометрия играет важную роль во многих различных областях информатики. Алгоритмы, структуры данных и методы, описанные в этой книге, предоставят вам инструменты, необходимые для успешного решения таких геометрических задач.

**1.4 Заметки и комментарии**

Каждая глава этой книги заканчивается разделом под названием «Заметки и комментарии». Эти разделы содержат информацию о происхождении результатов, описанных в главе, упоминают обобщения и улучшения, а также предоставляют ссылки на дополнительные материалы. Их можно пропустить, но они полезны для тех, кто хочет углубиться в тему главы. Дополнительную информацию также можно найти в **Handbook of Computational Geometry** [331] и **Handbook of Discrete and Computational Geometry** [191].

  

В этой главе подробно рассматривалась задача вычисления выпуклой оболочки множества точек на плоскости. Это классическая тема вычислительной геометрии, и литературы по ней существует огромное количество. Алгоритм, описанный в этой главе, известен как метод Грэма и основан на модификации, предложенной Эндрю [17], одного из первых алгоритмов Грэма [192]. Это лишь один из множества доступных алгоритмов с временной сложностью для решения этой задачи. Метод «разделяй и властвуй» был предложен Прапаратой и Хонгом [322]. Также существует инкрементальный метод, который добавляет точки по одной за на каждую вставку [321]. Овермарс и ван Левен обобщили этот подход до метода, в котором точки могут как добавляться, так и удаляться за [305]. Другие результаты о динамических выпуклых оболочках были получены Хершбергером и Сури [211], Чаном [83], а также Бродалом и Джейкобом [73].

  

Несмотря на то, что известно нижнее ограничение для этой задачи [393], многие исследователи пытались улучшить результат. Это имеет смысл, поскольку во многих приложениях количество точек, попадающих на выпуклую оболочку, относительно невелико, тогда как нижнее ограничение предполагает, что (почти) все точки оказываются на выпуклой оболочке. Поэтому полезно рассматривать алгоритмы, время выполнения которых зависит от сложности выпуклой оболочки. Джарвис [221] предложил технику обхода, часто называемую марш Джарвиса, которая вычисляет выпуклую оболочку за , где — сложность выпуклой оболочки. Та же временная сложность достигается алгоритмом Овермарса и ван Левена [303], основанным на более ранних работах Биката [79], Эдди [156], а также Грина и Сильвермана [193]. Преимущество этого алгоритма в том, что его ожидаемое время выполнения является линейным для многих распределений точек. Наконец, Киркпатрик и Сейдел [238] улучшили результат до , а недавно Чан [82] предложил гораздо более простой алгоритм с такой же сложностью.

**Выпуклая оболочка может быть определена в любом числе измерений.**

Выпуклые оболочки в трехмерном пространстве все еще могут быть вычислены за времени, как мы увидим в Главе 11. Однако для более высоких измерений сложность вычисления выпуклой оболочки уже не линейна относительно числа точек. Подробнее об этом можно узнать в заметках и комментариях Главы 11.

  

В последние годы было предложено несколько общих методов для обработки специальных случаев. Эти схемы символического возмущения изменяют входные данные таким образом, чтобы все вырождения исчезали. Однако возмущение выполняется только символически. Эта техника была введена Эдельсбруннером и Мюкке [164] и позже усовершенствована Япом [397] и Эмирисом и Канни [172, 171]. Символическое возмущение освобождает программиста от необходимости работать с вырождениями, но имеет некоторые недостатки: использование библиотеки символического возмущения замедляет алгоритм, а иногда необходимо восстанавливать «реальный результат» из «возмущенного результата», что не всегда легко. Эти недостатки привели Бурникеля и др. [78] к утверждению, что проще (с точки зрения усилий программирования) и эффективнее (с точки зрения времени выполнения) работать напрямую с вырождёнными входными данными.

  

**Робастность в геометрических алгоритмах** — это тема, которая недавно привлекла много внимания. Большинство геометрических сравнений можно сформулировать как вычисление знака некоторого определителя. Один из способов справиться с неточностью вычислений с плавающей точкой при вычислении этого знака — это выбрать малое пороговое значение и считать, что определитель равен нулю, если результат вычислений с плавающей точкой меньше . Когда этот подход реализуется наивно, это может привести к несоответствиям (например, для трех точек мы можем решить, что и , но ), что может привести к сбоям программы. Гибас и др. [198] показали, что сочетание такого подхода с интервалом арифметики и обратным анализом ошибок может дать робастные алгоритмы. Другой вариант — использование точной арифметики. В этом случае вычисляется столько битов определителя, сколько нужно для того, чтобы определить его знак. Это замедляет вычисления, но были разработаны методы, позволяющие удерживать штраф за производительность на относительно низком уровне [182, 256, 395]. Кроме этих общих подходов, существует ряд статей, посвященных робастным вычислениям в конкретных задачах [34, 37, 81, 145, 180, 181, 219, 279].

  

Мы дали краткий обзор областей применения, из которых были взяты наши примеры, чтобы показать мотивацию различных геометрических понятий и алгоритмов, рассмотренных в этой книге. Ниже приведены несколько ссылок на учебники, которые можно проконсультировать, если вы хотите узнать больше об этих областях. Конечно, существует много других хороших книг по этим темам, помимо тех, которые мы упомянули.

  

Существует большое количество книг по компьютерной графике. Книга Фоли и др. [179] является очень объемной и обычно считается одной из лучших по этой теме. Другие хорошие книги — это работы Ширли и др. [359] и Уотта [381]. Обширный обзор робототехники и задачи планирования движений можно найти в книге Шосета и др. [127], а также в более старых книгах Латомбэ [243] и Хопкрофта, Шварца и Шарира [217]. Дополнительную информацию о геометрических аспектах робототехники можно найти в книге Селига [348].

### Notes and References
There is a large collection of books about geographic information systems, but most of them do not consider algorithmic issues in much detail. Some general textbooks are the ones by DeMers [140], Longley et al. [257], and Worboys and Duckham [392]. Data structures for spatial data are described extensively in the book of Samet [335].  
The books by Faux and Pratt [175], Mortenson [285], and Hoffmann [216] are good introductory texts on CAD/CAM and geometric modeling.

---

### 1.5 Exercises

#### Exercise 1.1  
The convex hull of a set \( S \) is defined to be the intersection of all convex sets that contain \( S \). For the
### Заметки и ссылки  
Существует большое количество книг о географических информационных системах, но большинство из них не рассматривают алгоритмические аспекты подробно. Общие учебники включают книги DeMers [140], Longley и др. [257], а также Worboys и Duckham [392]. Структуры данных для пространственных данных подробно описаны в книге Samet [335].  
Книги Faux и Pratt [175], Mortenson [285] и Hoffmann [216] являются хорошими вводными текстами по CAD/CAM и геометрическому моделированию.  

---

### 1.5 Упражнения  

#### Упражнение 1.1

Выпуклая оболочка множества $S$ определяется как пересечение всех выпуклых множеств, содержащих $S$. Для выпуклой оболочки множества точек указывалось, что это выпуклое множество с наименьшим периметром. Мы хотим показать, что эти определения эквивалентны.
a. Докажите, что пересечение двух выпуклых множеств снова выпуклое. Это подразумевает, что пересечение конечного набора выпуклых множеств также выпуклое.
b. Докажите, что многоугольник с наименьшим периметром $\mathcal{P}$, содержащий множество точек $\mathcal{P}$, является выпуклым.
c. Докажите, что любое выпуклое множество, содержащее множество точек $\mathcal{P}$, включает в себя многоугольник с наименьшим периметром $\mathcal{P}$.
#### Упражнение 1.2
Пусть $P$ — это множество точек на плоскости. Пусть $\mathcal{P}$ — это выпуклый многоугольник, вершины которого являются точками из $P$, и который содержит все точки в $P$. Докажите, что этот многоугольник $\mathcal{P}$ определяется однозначно и является пересечением всех выпуклых множеств, содержащих $\mathcal{P}$.
#### Упражнение 1.3

Пусть $E$ — неотсортированное множество из $n$ отрезков, которые являются рёбрами выпуклого многоугольника. Опишите алгоритм за $O(n \log n)$, который вычисляет из $E$ список всех вершин многоугольника, отсортированных в порядке часовой стрелки.

#### Упражнение 1.4  
Для алгоритма выпуклой оболочки нужно уметь проверять, находится ли точка $r$ слева или справа от направленной прямой, проходящей через две точки $p$ и $q$. Пусть $p = (p_x, p_y)$,  $q = (q_x, q_y)$ ,  и  $r = (r_x, r_y)$.  
a. Покажите, что знак определителя  
$$
D =  
\begin{vmatrix}  
1 & p_x & p_y \\  
1 & q_x & q_y \\  
1 & r_x & r_y  
\end{vmatrix}    
$$
определяет, находится ли $r$ слева или справа от прямой.  

b. Покажите, что  $|D|$ фактически равен удвоенной площади треугольника, определённого $p, q$ и  $r$.  

c. Почему это является привлекательным способом реализации базовой проверки в алгоритме CONVEXHULL? Приведите аргументы как для целых, так и для вещественных координат.
#### Упражнение 1.5

Проверьте, что алгоритм CONVEXHULL с указанными модификациями корректно вычисляет выпуклую оболочку, включая вырожденные множества точек. Рассмотрите, например, такие сложные случаи, как множество точек, которые все лежат на одной (вертикальной) прямой.
#### Упражнение 1.6

Во многих ситуациях нужно вычислять выпуклые оболочки объектов, отличных от точек.

a. Пусть $S$ — это множество из $n$ отрезков на плоскости. Докажите, что выпуклая оболочка $S$ совпадает с выпуклой оболочкой $2n$ конечных точек этих отрезков.

b.* Пусть $\mathcal{P}$ — невыпуклый многоугольник. Опишите алгоритм, который вычисляет выпуклую оболочку $\mathcal{P}$ за $O(n)$ времени.

*Подсказка:* используйте вариант алгоритма CONVEXHULL, в котором вершины обрабатываются не в лексикографическом порядке, а в каком-то другом порядке.
#### Упражнение 1.7
Рассмотрите следующий альтернативный подход к вычислению выпуклой оболочки множества точек на плоскости. Мы начинаем с самой правой точки $p_1$, которая является первой точкой выпуклой оболочки. Теперь представим, что мы начинаем с вертикальной прямой и вращаем её по часовой стрелке, пока она не коснётся другой точки $p_2$. Это вторая точка выпуклой оболочки. Продолжаем вращать прямую, но теперь вокруг $p_2$, пока не достигнем точки $p_3$. Таким образом, мы продолжаем, пока снова не достигнем $p_1$.

a. Напишите псевдокод для этого алгоритма.
b. Какие вырожденные случаи могут возникнуть, и как с ними справляться?
c. Докажите, что алгоритм корректно вычисляет выпуклую оболочку.
d. Докажите, что алгоритм может быть реализован с временем работы $O(n \cdot h)$, где $h$ — сложность выпуклой оболочки.
e. Какие проблемы могут возникнуть при работе с неточными вычислениями в формате с плавающей запятой?
#### Упражнение 1.8

Алгоритм за $O(n \log n)$ для вычисления выпуклой оболочки множества из $n$ точек на плоскости, описанный в этой главе, основан на парадигме пошагового построения: точки добавляются по одной, а выпуклая оболочка обновляется после каждого добавления. В этом упражнении мы разработаем алгоритм, основанный на другой парадигме, а именно на разделении и завоевании.

a. Пусть $\mathcal{P_1}$ и $\mathcal{P_2}$ — два непересекающихся выпуклых многоугольника с $n$ вершинами в общей сложности. Разработайте алгоритм за $O(n)$, который вычисляет выпуклую оболочку $\mathcal{P_1} \cup \mathcal{P_2}$.

b. Используйте алгоритм из части a для разработки алгоритма за $O(n \log n)$, основанного на разделении и завоевании, для вычисления выпуклой оболочки множества из $n$ точек на плоскости.

![[Pasted image 20241211101715.png]]
#### Упражнение 1.9

Предположим, что у нас есть подпрограмма CONVEXHULL для вычисления выпуклой оболочки множества точек на плоскости. Её выход — это список вершин выпуклой оболочки, отсортированных по часовой стрелке. Теперь пусть $S = \{x_1, x_2, \dots, x_n\}$ — множество из $n$ чисел. Покажите, что $S$ можно отсортировать за $O(n)$ времени плюс время одного вызова CONVEXHULL. Поскольку задача сортировки имеет нижнюю границу $\Omega(n \log n)$, это подразумевает, что задача выпуклой оболочки...
Задача выпуклой оболочки также имеет нижнюю границу $\Omega(n \log n)$. Таким образом, представленный в этой главе алгоритм является асимптотически оптимальным.

Пусть $S$ — множество из $n$ (возможно, пересекающихся) единичных окружностей на плоскости. Требуется вычислить выпуклую оболочку множества $S$.

a. Докажите, что граница выпуклой оболочки $S$ состоит из прямолинейных отрезков и частей окружностей из $S$.

b. Докажите, что каждая окружность может появиться на границе выпуклой оболочки не более одного раза.

c. Пусть $S'$ — множество точек, являющихся центрами окружностей в $S$. Докажите, что окружность из $S$ появляется на границе выпуклой оболочки, если и только если её центр лежит на выпуклой оболочке $S'$.

d. Разработайте алгоритм за $O(n \log n)$ для вычисления выпуклой оболочки $S$.

e.* Разработайте алгоритм за $O(n \log n)$ для случая, когда окружности в $S$ имеют разные радиусы.

## 2 Пересечение отрезков  
### Наложение тематических карт  

Когда вы путешествуете по стране, карты являются бесценным источником информации. Они показывают, где находятся достопримечательности, указывают дороги и железнодорожные линии, отмечают небольшие озера и многое другое. Однако карты могут быть и источником разочарования, так как бывает трудно найти нужную информацию: даже зная приблизительное местоположение небольшого города, его порой сложно обнаружить на карте.  
![[Pasted image 20241210154610.png]]


Чтобы сделать карты более удобными для восприятия, геоинформационные системы (ГИС) разделяют их на несколько слоев. Каждый слой представляет собой тематическую карту, то есть содержит только один тип информации. Например, будет слой с дорогами, слой с городами, слой с реками и так далее. Тема слоя может быть и более абстрактной. Например, можно создать слой с плотностью населения, среднегодовым количеством осадков, ареалом обитания гризли или типами растительности.  Тип геометрической информации в каждом слое может сильно различаться. Так, слой дорожной карты может хранить дороги в виде коллекций отрезков (или, возможно, кривых), слой с городами может содержать точки, подписанные названиями городов, а слой с растительностью может представлять карту как разделение на регионы с указанием типа растительности.  

Пользователи геоинформационной системы могут выбрать для отображения одну из тематических карт. Чтобы найти небольшой город, вы можете выбрать слой с городами, избегая отвлечения от другой информации, такой как названия рек и озер. После того как вы найдете город, вам, вероятно, захочется узнать, как до него добраться. Для этого ГИС позволяют накладывать несколько карт друг на друга — см. Рисунок 2.1. 
![[Pasted image 20241210155604.png]]

Наложив слой с дорогами и слой с городами, вы сможете выяснить маршрут к городу.  Когда два или более слоя тематических карт отображаются вместе, пересечения на наложении становятся точками особого интереса. Например, при просмотре наложения слоев с дорогами и реками полезно, чтобы пересечения были четко отмечены. В этом случае две карты представляют собой сети, а пересечения являются точками. В других случаях интерес представляют пересечения целых регионов. Например, географы, изучающие климат, могут быть заинтересованы в поиске регионов, где растут сосновые леса, а годовое количество осадков составляет от 1000 мм до 1500 мм. Эти регионы представляют собой пересечения областей, отмеченных как «сосновый лес» на карте растительности, и областей, помеченных как «1000–1500» на карте осадков.  

## 2.1 Пересечение отрезков  
![[Pasted image 20241210155720.png]]
Сначала мы рассмотрим простейшую форму задачи наложения карт, когда два слоя карты представляют собой сети, изображенные как наборы отрезков. Например, слой карты, на котором хранятся дороги, железные дороги или реки в мелком масштабе. Обратите внимание, что кривые линии можно аппроксимировать набором маленьких отрезков.  На первом этапе нас не будут интересовать области, образованные этими отрезками. Позже мы рассмотрим более сложную ситуацию, когда карты представляют собой не просто сети, а разбиения плоскости на регионы с явным значением.  Чтобы решить задачу наложения сетей, сначала нужно определить ее в геометрическом контексте. Для наложения двух сетей геометрическая задача формулируется следующим образом: даны два набора отрезков, требуется вычислить все точки пересечения между отрезком из одного набора и отрезком из другого.  Однако эта постановка задачи еще недостаточно точна, поскольку не определено, когда два отрезка считаются пересекающимися. В частности, пересекаются ли два отрезка, если один из их концов лежит на другом? Иными словами, нужно уточнить, являются ли входные отрезки открытыми или закрытыми.  Для принятия решения следует вернуться к приложению, то есть к задаче наложения сетей. Дороги на карте дорог и реки на карте рек представлены цепочками отрезков, поэтому пересечение дороги и реки соответствует пересечению внутренних точек одной цепочки с внутренними точками другой цепочки. Это не обязательно означает пересечение внутренних точек двух отдельных отрезков: точка пересечения может совпадать с концом одного из отрезков цепочки.  На самом деле такая ситуация нередко встречается, поскольку извилистые реки представляются множеством мелких отрезков, а координаты концов отрезков могут быть округлены при оцифровке карт.  Таким образом, мы заключаем, что отрезки следует определять как закрытые, чтобы конец одного отрезка, лежащий на другом, считался пересечением.  

Чтобы немного упростить описание, мы объединим отрезки из двух наборов в один и вычислим все пересечения между отрезками в этом наборе. Таким образом, мы обязательно найдем все нужные пересечения. Мы также можем найти пересечения между отрезками из одного набора. На самом деле, это точно произойдет, потому что в нашем случае отрезки одного набора формируют цепочки, а совпадающие концы отрезков считаются пересечениями. Эти дополнительные пересечения можно отфильтровать позже, просто проверив для каждого найденного пересечения, принадлежат ли оба отрезка одному и тому же набору.  Таким образом, задача формулируется следующим образом: дан набор $S$ из $n$ замкнутых отрезков на плоскости, требуется найти все точки пересечения между отрезками в $S$.  
![[Pasted image 20241210160441.png]]
На первый взгляд задача не кажется сложной: можно просто взять каждую пару отрезков, вычислить, пересекаются ли они, и, если да, записать точку их пересечения. Этот алгоритм прямого перебора явно требует  $O(n^2)$ времени. В некотором смысле это оптимально: если каждая пара отрезков пересекается, любой алгоритм должен занять  $\Omega(n^2)$  времени, так как необходимо сообщить обо всех пересечениях. Аналогичный пример можно привести и для наложения двух сетей.  Однако в практических ситуациях большинство отрезков не пересекаются или пересекаются только с несколькими другими, поэтому общее число точек пересечения намного меньше квадратичного. Было бы полезно иметь алгоритм, работающий быстрее в таких случаях. Другими словами, нужен алгоритм, время работы которого зависит не только от числа отрезков на входе, но и от количества точек пересечения. Такой алгоритм называют алгоритмом, зависящим от размера выхода (output-sensitive algorithm): его время работы чувствительно к размеру выходных данных. Мы также можем назвать его зависящим от пересечений, так как именно их количество определяет размер выхода.  
![[Pasted image 20241210160451.png]]
Как избежать проверки всех пар отрезков на пересечение? Здесь необходимо использовать геометрию ситуации: отрезки, находящиеся близко друг к другу, являются кандидатами на пересечение, в отличие от отрезков, находящихся далеко друг от друга. Ниже мы рассмотрим, как можно использовать это наблюдение для создания алгоритма, чувствительного к выходу, для задачи о пересечении отрезков.  

Пусть  $S := \{s_1, s_2, \dots, s_n\}$  — набор отрезков, для которого мы хотим вычислить все пересечения. Мы хотим избежать проверки пар отрезков, находящихся далеко друг от друга. Но как это сделать? Сначала исключим простой случай. Определим \( y \)-интервал отрезка как его ортогональную проекцию на ось \( y \). Если \( y \)-интервалы пары отрезков не пересекаются — можно сказать, что они далеко друг от друга по \( y \)-направлению — тогда они не могут пересекаться. Следовательно, нужно проверять только пары отрезков, \( y \)-интервалы которых пересекаются, то есть те, для которых существует горизонтальная линия, пересекающая оба отрезка.  Чтобы найти такие пары, представим, что мы проводим линию \( $\ell$ \), которая опускается вниз по плоскости, начиная с позиции выше всех отрезков Во время проведения воображаемой линии мы будем отслеживать все отрезки, которые пересекают её — детали этого будут объяснены позже — чтобы найти нужные пары. 
![[Pasted image 20241210160719.png]] 
Этот тип алгоритма называется **`алгоритмом сканирующей прямой (plane sweep)`**, а линия \( $\ell$ \) называется **сканирующей линией (sweep line)**. **Статус сканирующей линии** — это набор отрезков, пересекающих её. Статус меняется, пока линия движется вниз, но не непрерывно. Только в определённых точках требуется обновление статуса. Эти точки называются **событийными точками (event points)** алгоритма сканирующей прямой. В данном алгоритме событийные точки — это конечные точки отрезков.  

Моменты, когда сканирующая линия достигает событийной точки, — это единственные моменты, когда алгоритм выполняет действия: обновляет статус сканирующей линии и выполняет некоторые проверки на пересечение. В частности, если событийная точка — это верхняя конечная точка отрезка, то новый отрезок начинает пересекать сканирующую линию и должен быть добавлен в статус. Этот отрезок проверяется на пересечение с другими отрезками, уже пересекающими линию. Если событийная точка — это нижняя конечная точка, то отрезок перестаёт пересекать сканирующую линию и должен быть удалён из статуса. Таким образом, мы проверяем только пары отрезков, для которых существует горизонтальная линия, пересекающая оба отрезка.  

К сожалению, этого недостаточно: всё ещё могут быть ситуации, когда мы проверяем квадратичное количество пар, несмотря на то, что количество точек пересечения невелико. Простой пример — набор вертикальных отрезков, которые все пересекают ось \( x \). Таким образом, алгоритм не является чувствительным к выходу. Проблема в том, что два отрезка, пересекающие сканирующую линию, всё ещё могут быть далеко друг от друга по горизонтали.  
![[Pasted image 20241211122711.png]]
Давайте упорядочим отрезки слева направо в порядке их пересечения со сканирующей линией, чтобы учесть понятие близости по горизонтали. Мы будем проверять отрезки только тогда, когда они смежны в горизонтальном порядке. Это значит, что любой новый отрезок проверяется только с двумя другими отрезками, а именно с теми, которые находятся сразу слева и справа от его верхней конечной точки. Позже, когда сканирующая линия сдвинется вниз, отрезок может стать смежным с другими отрезками, с которыми он будет проверен.  

Наша новая стратегия должна быть отражена в статусе алгоритма: статус теперь соответствует упорядоченной последовательности отрезков, пересекающих сканирующую линию. Новый статус изменяется не только в конечных точках отрезков; он также изменяется в точках пересечения, где порядок пересекающихся отрезков меняется. Когда это происходит, мы должны проверить два отрезка, которые поменялись местами, на пересечение с их новыми соседями. Это новый тип событийной точки.  

Прежде чем пытаться превратить эти идеи в эффективный алгоритм, убедимся, что подход корректен. Мы сократили количество проверяемых пар, но найдём ли мы все пересечения? Другими словами, если два отрезка \( s_i \) и \( s_j \) пересекаются, существует ли всегда положение сканирующей линии \( \ell \), где \( s_i \) и \( s_j \) будут смежны вдоль \( \ell \)?  

Сначала проигнорируем сложные случаи: предположим, что ни один отрезок не является горизонтальным, любые два отрезка пересекаются не более чем в одной точке (они не перекрываются), и ни три отрезка не пересекаются в одной общей точке. Позже мы увидим, что эти случаи легко обработать, но сейчас удобнее их не учитывать. Пересечения, где конечная точка одного отрезка лежит на другом, легко обнаруживаются, когда сканирующая линия...

Пересечения, где конечная точка одного отрезка лежит на другом, легко обнаруживаются, когда сканирующая линия достигает этой конечной точки. Единственный вопрос заключается в том, всегда ли пересечения между внутренними частями отрезков обнаруживаются.
![[Pasted image 20241211122740.png]]
**Лемма 2.1**  
Пусть \( s_i \) и \( s_j \) — два не горизонтальных отрезка, внутренние части которых пересекаются в одной точке \( p \), и предположим, что нет третьего отрезка, проходящего через \( p \). Тогда существует событийная точка выше \( p \), где \( s_i \) и \( s_j \) становятся соседними и проверяются на пересечение.

**Доказательство.**  
Пусть \( \ell \) — горизонтальная линия, немного выше \( p \). Если \( \ell \) достаточно близка к \( p \), то \( s_i \) и \( s_j \) должны быть соседними вдоль \( \ell \). (Точнее, мы должны выбрать \( \ell \) так, чтобы на ней не было событийных точек, а также между \( \ell \) и горизонтальной линией через \( p \)). Иными словами, существует положение сканирующей линии, где \( s_i \) и \( s_j \) являются соседними. С другой стороны, \( s_i \) и \( s_j \) не являются соседними, когда алгоритм начинается, потому что сканирующая линия начинается выше всех отрезков, а статус пуст. Следовательно, должна быть событийная точка \( q \), где \( s_i \) и \( s_j \) становятся соседними и проверяются на пересечение.

Таким образом, наш подход корректен, по крайней мере, если мы не принимаем в расчёт сложные случаи, упомянутые ранее. Теперь мы можем перейти к разработке алгоритма сканирующей прямой. Давайте кратко резюмируем общий подход. Мы мысленно перемещаем горизонтальную сканирующую линию \( \ell \) вниз по плоскости. Сканирующая линия останавливается в определённых событийных точках; в нашем случае это конечные точки отрезков (известные заранее) и точки пересечения, которые вычисляются в процессе работы. Пока сканирующая линия движется, мы поддерживаем упорядоченную последовательность отрезков, которые она пересекает. Когда сканирующая линия останавливается в событийной точке, последовательность отрезков изменяется, и в зависимости от типа событийной точки мы должны выполнить несколько действий для обновления статуса и обнаружения пересечений.

Когда событийной точкой является верхняя конечная точка отрезка, появляется новый отрезок, пересекающий сканирующую линию. Этот отрезок должен быть проверен на пересечение с двумя соседними отрезками вдоль сканирующей линии. Важны только точки пересечения ниже сканирующей линии; точки выше уже обнаружены. Например, если отрезки \( s_i \) и \( s_k \) являются соседними на сканирующей линии, и появляется новая верхняя конечная точка отрезка \( s_j \) между ними, то мы должны проверить \( s_j \) на пересечение с \( s_i \) и \( s_k \). Если мы обнаружим пересечение ниже сканирующей линии, то найдена новая событийная точка. После обработки верхней конечной точки алгоритм переходит к следующей событийной точке.

Когда событийной точкой является пересечение, два пересекающихся отрезка меняют свой порядок. Каждый из них получает (максимум) одного нового соседа, с которым он проверяется на пересечение. Опять же, важны только пересечения ниже сканирующей линии. Допустим, четыре отрезка \( s_j, s_k, s_l \) и \( s_m \) находятся в этом порядке на сканирующей линии в момент достижения точки пересечения отрезков \( s_k \) и \( s_l \). Тогда \( s_k \) и \( s_l \) меняются местами, и мы должны проверить \( s_l \) и \( s_j \) на пересечение ниже сканирующей линии, а также \( s_k \) и \( s_m \). Найденные новые пересечения, конечно же, также являются событийными точками для алгоритма. Однако обратите внимание, что эти события могли быть обнаружены ранее, если пара, которая становится соседней, уже была соседней до этого.
![[Pasted image 20241211122815.png]]![[Pasted image 20241211122825.png]]
Когда событийной точкой является нижняя конечная точка отрезка, его два соседа становятся соседними и должны быть проверены на пересечение. Если они пересекаются ниже сканирующей линии, то точка их пересечения становится новой событийной точкой. (Снова, это событие могло быть обнаружено ранее.) Предположим, три отрезка \( s_k, s_l \) и \( s_m \) расположены в этом порядке на сканирующей линии в момент, когда встречается нижняя конечная точка \( s_l \). Тогда \( s_k \) и \( s_m \) станут соседними, и их нужно будет проверить на пересечение.

После того как сканирующая линия пройдет через всю плоскость — точнее, после обработки последней событийной точки — мы вычислим все точки пересечения. Это гарантируется следующим инвариантом, который верен в любой момент выполнения алгоритма: все точки пересечения выше сканирующей линии были корректно вычислены.

После этого краткого описания алгоритма пришло время углубиться в детали. Также необходимо рассмотреть вырожденные случаи, такие как пересечение трех или более отрезков в одной точке. Сначала нужно определить, что мы ожидаем от алгоритма в таких случаях. Мы могли бы требовать, чтобы алгоритм просто сообщал каждую точку пересечения один раз, но кажется более полезным, если он будет предоставлять список отрезков, проходящих через каждую точку пересечения или имеющих её как конечную точку. Существует и другой особый случай, для которого следует чётко определить ожидаемый результат, а именно частичное перекрытие двух отрезков. Однако для простоты мы будем игнорировать этот случай в остальной части раздела.
![[Pasted image 20241211122846.png]]![[Pasted image 20241211122852.png]]
Мы начнем с описания структур данных, используемых в алгоритме.  

Во-первых, нам нужна структура данных — **очередь событий**, которая хранит события. Мы обозначим её как \( Q \). Необходима операция, которая удаляет из \( Q \) следующее событие, возвращает его и позволяет обработать. Это событие является самым верхним из событий ниже сканирующей линии. Если у двух событий одинаковая \( y \)-координата, то будет возвращено то, у которого меньшая \( x \)-координата. Иными словами, события на одной горизонтальной линии обрабатываются слева направо. Это подразумевает, что мы должны рассматривать левую конечную точку горизонтального отрезка как его верхнюю конечную точку, а правую — как нижнюю. Вы также можете представить это следующим образом: вместо горизонтальной сканирующей линии представьте, что она слегка наклонена вверх. В результате сканирующая линия достигает левой конечной точки горизонтального отрезка чуть раньше, чем правой.

Очередь событий должна поддерживать добавление новых событий, так как они будут вычисляться в процессе работы. Заметьте, что две событийные точки могут совпадать, например, верхние конечные точки двух различных отрезков. Удобно обрабатывать это как одну событийную точку. Таким образом, добавление событий должно проверять, присутствует ли уже событие в \( Q \).

Мы реализуем очередь событий следующим образом. Определим порядок $\prec$ на событийных точках, который представляет порядок их обработки. Таким образом, если \( p \) и \( q \) — две событийные точки, то \( p \prec q \), если \( p_y > q_y \), или если \( p_y = q_y \) и \( p_x < q_x \). Мы храним событийные точки в сбалансированном дереве поиска, упорядоченном по \( \prec \). С каждой событийной точкой \( p \) в \( Q \) будет храниться информация о сегментах, начинающихся в \( p \), то есть тех сегментах, у которых \( p \) является верхней конечной точкой. Эта информация понадобится для обработки событий. Обе операции — извлечение следующего события и добавление нового — выполняются за \( O(\log m) \), где \( m \) — количество событий.

![[Pasted image 20241211122914.png]]![[Pasted image 20241211122921.png]]
в $Q$. (Мы не используем кучу для реализации очереди событий, так как нам нужно иметь возможность проверять, присутствует ли данное событие уже в $Q$.)

Во-вторых, нам нужно поддерживать статус алгоритма. Это упорядоченная последовательность отрезков, пересекающих сканирующую линию. Структура данных статуса, обозначаемая как $T$, используется для доступа к соседям данного отрезка $s$, чтобы они могли быть проверены на пересечение с $s$. Структура данных статуса должна быть динамичной: когда отрезки начинают или заканчивают пересекать сканирующую линию, они должны быть добавлены или удалены из структуры. Поскольку на отрезках в структуре данных статуса задан строгий порядок, можно использовать сбалансированное дерево поиска в качестве структуры статуса.

Если вы привыкли к бинарным деревьям поиска, которые хранят только числа, это может удивить. Но бинарные деревья поиска могут хранить любой набор элементов, если для этих элементов определен порядок.

Подробнее: мы храним отрезки, пересекающие сканирующую линию, упорядоченными в листьях сбалансированного бинарного дерева поиска $T$. Левый-направо порядок отрезков вдоль сканирующей линии соответствует порядку листьев в $T$. Мы также должны хранить информацию во внутренних узлах, чтобы направлять поиск вниз по дереву к листьям. В каждом внутреннем узле хранится отрезок из правого крайнего листа его левого поддерева. (Альтернативно, можно хранить отрезки только во внутренних узлах. Это сэкономит место. Однако концептуально проще думать об отрезках во внутренних узлах как о значениях для управления поиском, а не как о данных. Хранение отрезков в листьях также упрощает описание некоторых алгоритмов.)

Предположим, мы ищем в $T$ отрезок, расположенный непосредственно слева от некоторой точки $p$, лежащей на сканирующей линии. В каждом внутреннем узле $\nu$ мы проверяем, лежит ли $p$ слева или справа от отрезка, хранящегося в $\nu$. В зависимости от результата мы спускаемся в левое или правое поддерево $\nu$, в конечном итоге попадая в лист. Либо этот лист, либо лист, непосредственно слева от него, хранит искомый отрезок. Аналогичным образом мы можем найти отрезок, расположенный непосредственно справа от $p$, или отрезки, содержащие $p$. Отсюда следует, что каждая операция обновления и поиска соседей занимает $O(\log n)$ времени.

Очередь событий $Q$ и структура статуса $T$ — это единственные две структуры данных, которые нам нужны. Глобальный алгоритм можно описать следующим образом.

**Алгоритм FINDINTERSECTIONS($S$)**  
**Вход:** Набор $S$ отрезков на плоскости.  
**Выход:** Набор точек пересечения отрезков из $S$ с указанием, какие отрезки проходят через каждую точку.  
1. Инициализировать пустую очередь событий $Q$. Затем вставить конечные точки отрезков в $Q$; при вставке верхней конечной точки соответствующий отрезок должен быть связан с ней.  
2. Инициализировать пустую структуру статуса $T$.  
3. Пока $Q$ не пуста:  
   - Определить следующую точку события $p$ в $Q$ и удалить её.  
   - Выполнить HANDLEEVENTPOINT($p$).
![[Pasted image 20241211123455.png]]
Мы уже видели, как обрабатываются события: в конечных точках отрезков нужно вставить или удалить отрезки из структуры статуса $T$, а в точках пересечения нужно изменить порядок двух отрезков. В обоих случаях также необходимо выполнить тесты на пересечение между отрезками, которые становятся соседями после изменения Событие. В вырожденных случаях, когда несколько отрезков участвуют в одной точке события, детали становятся немного сложнее. Следующая процедура описывает, как правильно обрабатывать точки событий; это иллюстрируется на рисунке 2.2.

**HANDLEEVENTPOINT($p$)**  
1. Пусть $U(p)$ — множество отрезков, верхняя конечная точка которых совпадает с $p$; эти отрезки хранятся с точкой события $p$. (Для горизонтальных отрезков верхняя конечная точка по определению является левой конечной точкой.)  
2. Найти все отрезки, хранящиеся в $T$, которые содержат $p$; они являются соседними в $T$. Пусть $L(p)$ обозначает подмножество найденных отрезков, нижняя конечная точка которых совпадает с $p$, а $C(p)$ — подмножество найденных отрезков, которые содержат $p$ внутри.  
3. Если $L(p) \cup U(p) \cup C(p)$ содержит более одного отрезка, то:  
   - Сообщить $p$ как точку пересечения вместе с $L(p)$, $U(p)$ и $C(p)$.  
4. Удалить отрезки из $L(p) \cup C(p)$ из $T$.  
5. Вставить отрезки из $U(p) \cup C(p)$ в $T$. Порядок отрезков в $T$ должен соответствовать порядку, в котором они пересекаются сканирующей линией чуть ниже $p$. Если есть горизонтальный отрезок, он должен быть последним среди всех отрезков, содержащих $p$.  
   - (* Удаление и повторная вставка отрезков из $C(p)$ переворачивает их порядок. *)  
6. Если $U(p) \cup C(p) = \emptyset$, то:  
   - Пусть $s_l$ и $s_r$ — левые и правые соседи $p$ в $T$.  
   - Выполнить $FINDNEWEVENT(s_l, s_r, p)$.  
7. В противном случае:  
   - Пусть $s'$ — самый левый отрезок из $U(p) \cup C(p)$ в $T$.  
   - Пусть $s_l$ — левый сосед $s'$ в $T$.  
   - Выполнить $FINDNEWEVENT(s_l, s', p)$.  
   - Пусть $s''$ — самый правый отрезок из $U(p) \cup C(p)$ в $T$.  
   - Пусть $s_r$ — правый сосед $s''$ в $T$.  
   - Выполнить $FINDNEWEVENT(s'', s_r, p)$.  

Обратите внимание, что в строках 8–16 предполагается, что $s_l$ и $s_r$ действительно существуют. Если они не существуют, соответствующие шаги, очевидно, не должны выполняться.
![[Pasted image 20241211123542.png]]

Процедуры для нахождения новых точек пересечения просты: они просто проверяют два отрезка на пересечение. Единственное, на что нужно обратить внимание, это было ли уже обработано найденное пересечение ранее. Если нет горизонтальных отрезков, то пересечение еще не обработано, если точка пересечения находится ниже сканирующей линии. Но как быть с горизонтальными отрезками? Напомним, что события с одинаковой $y$-координатой обрабатываются слева направо. Это подразумевает, что нас интересуют точки пересечения, лежащие справа от текущей точки события. Следовательно, процедура $FINDNEWEVENT$ определяется следующим образом:

**FINDNEWEVENT($s_l$, $s_r$, $p$)**  
1. Если $s_l$ и $s_r$ пересекаются ниже сканирующей линии, или на ней и справа от текущей точки события $p$, и это пересечение еще не добавлено как событие в $Q$:  
2. Тогда вставить точку пересечения как событие в $Q$.  

### Раздел 2.1  
**Пересечение отрезков прямых**  

Как насчет корректности нашего алгоритма? Очевидно, что $FINDINTERSECTIONS$ находит только истинные точки пересечения, но находит ли он все из них? Следующая лемма утверждает, что это действительно так.

**Лемма 2.2.** Алгоритм $FINDINTERSECTIONS$ правильно вычисляет все точки пересечения и отрезки, которые их содержат.  

**Доказательство.** Напомним, что приоритет события определяется его $y$-координатой, и что при одинаковых $y$-координатах приоритет получает событие с меньшей $x$-координатой. Докажем лемму индукцией по приоритету точек событий.  

Пусть $p$ — точка пересечения, и предположим, что все точки пересечения $q$ с более высоким приоритетом были правильно вычислены. Мы докажем, что $p$ и отрезки, содержащие $p$, вычислены корректно. Пусть $U(p)$ — множество отрезков, у которых $p$ является верхней конечной точкой (или, для горизонтальных отрезков, левой конечной точкой), $L(p)$ — множество отрезков, у которых $p$ является нижней конечной точкой (или, для горизонтальных отрезков, правой конечной точкой), а $C(p)$ — множество отрезков, содержащих $p$ внутри.

Во-первых, предположим, что $p$ является конечной точкой одного или нескольких отрезков. В этом случае $p$ хранится в очереди событий $Q$ с самого начала алгоритма. Отрезки из $U(p)$ хранятся вместе с $p$, поэтому они будут найдены. Отрезки из $L(p)$ и $C(p)$ хранятся в $T$, когда обрабатывается $p$, поэтому они будут найдены на шаге 2 процедуры $HANDLEEVENTPOINT$. Следовательно, $p$ и все связанные с ним отрезки определяются правильно, если $p$ является конечной точкой одного или нескольких отрезков.

Теперь предположим, что $p$ не является конечной точкой отрезка. Все, что нужно показать, это что $p$ будет добавлена в $Q$ в какой-то момент. Заметьте, что все отрезки, которые участвуют, содержат $p$ внутри. Упорядочим эти отрезки по углу вокруг $p$, и пусть $s_i$ и $s_j$ — два соседних отрезка. Следуя доказательству Леммы 2.1, мы видим, что существует точка события с более высоким приоритетом, чем $p$, такая, что $s_i$ и $s_j$ становятся соседними, когда $q$ проходит. В Лемме 2.1 мы предполагали для простоты, что $s_i$ и $s_j$ не горизонтальны, но доказательство можно легко адаптировать.
горизонтальные отрезки. По индукции, точка события $q$ была обработана корректно, что означает, что $p$ обнаружена и добавлена в $Q$.  

Таким образом, у нас есть корректный алгоритм. Но удалось ли нам разработать алгоритм, зависящий от объема вывода? Ответ — да: время работы алгоритма составляет $O((n + k) \log n)$, где $k$ — размер вывода. Следующая лемма утверждает даже более сильный результат: время работы составляет $O((n + I) \log n)$, где $I$ — количество точек пересечения. Это сильнее, так как для одной точки пересечения вывод может включать большое количество отрезков, например, в случае, когда множество отрезков пересекаются в одной точке.  

**Лемма 2.3.** Время работы алгоритма $FINDINTERSECTIONS$ для множества $S$, содержащего $n$ отрезков на плоскости, равно $O(n \log n + I \log n)$, где $I$ — количество точек пересечения отрезков в $S$.  

**Доказательство.** Алгоритм начинается с построения очереди событий на конечных точках отрезков. Поскольку мы реализовали очередь событий как сбалансированное дерево поиска, это занимает $O(n \log n)$ времени. Инициализация структуры статуса занимает константное время. Затем начинается сканирование плоскости, и все события обрабатываются.  

Для обработки события выполняются три операции над очередью событий $Q$: само событие удаляется из $Q$ на шаге 4 процедуры $FINDINTERSECTIONS$, и может быть выполнено одно или два вызова $FINDNEWEVENT$, которые могут привести к добавлению максимум двух новых событий в $Q$. Удаления и вставки в $Q$ занимают $O(\log n)$ времени каждое. Также выполняются операции — вставки, удаления и поиск соседей — в структуре статуса $T$, которые занимают $O(\log n)$ времени каждая.  

Количество операций линейно относительно $m(p) := \text{card}(L(p) \cup U(p) \cup C(p))$, где $m(p)$ — количество отрезков, участвующих в событии. Если обозначить сумму всех $m(p)$ по всем точкам событий $p$ как $m$, время работы алгоритма составляет $O(m \log n)$.  

Очевидно, что $m = O(n + k)$, где $k$ — размер вывода; в конце концов, всякий раз, когда $m(p) > 1$, мы сообщаем все отрезки, участвующие в событии, и единственные события, включающие один отрезок, это конечные точки отрезков. Но мы хотим доказать, что $m = O(n + I)$, где $I$ — количество точек пересечения.  

Чтобы показать это, мы будем интерпретировать множество отрезков как планарный граф, встроенный в плоскость. (Если вы не знакомы с терминологией планарных графов, вам следует сначала прочитать первые абзацы Раздела 2.2.) Его вершины — это конечные точки отрезков и точки пересечения отрезков, а его ребра — части отрезков, соединяющие вершины.  

Рассмотрим точку события $p$. Это вершина графа, и $m(p)$ ограничено степенью вершины. Следовательно, $m$ ограничено суммой степеней всех вершин нашего графа. Каждое ребро графа добавляет одну степень ровно двум вершинам (своим конечным точкам), поэтому $m$ ограничено $2n_e$, где $n_e$ — количество ребер графа.  

Давайте ограничим $n_e$ через $n$ и $I$. По определению, $n_v$, количество вершин, не превосходит $2n + I$. Известно, что в планарных графах $n_e = O(n_v)$, что доказывает наше утверждение. Но для полноты приведем аргумент здесь. Каждая грань планарного графа ограничена как минимум тремя ребрами — при условии, что есть хотя бы три отрезка — и ребро может ограничивать максимум две разные грани. Следовательно, $n_f$, количество граней, не превосходит $2n_e / 3$.  
![[Pasted image 20241211124731.png]]
Теперь используем формулу Эйлера, которая гласит, что для любого планарного графа с $n_v$ вершинами, $n_e$ ребрами и $n_f$ гранями следующее соотношение выполняется:

$n_v - n_e + n_f = 2.$  
Равенство достигается тогда и только тогда, когда граф связен. Подставляя ограничения на $n_v$ и $n_f$ в эту формулу, получаем:  
$2 (2n + I) - n_e + \frac{2n_e}{3} = 2(2n + I) - \frac{n_e}{3}.$  
Следовательно, $n_e \leq 6n + 3I - 6$, и $m \leq 12n + 6I - 12$, что доказывает оценку времени работы.  

Теперь проанализируем другой аспект сложности — объем памяти, используемой алгоритмом. Дерево $T$ хранит каждый отрезок не более одного раза, так что его объем памяти составляет $O(n)$. Однако размер $Q$ может быть больше. Алгоритм добавляет точки пересечения в $Q$ по мере их обнаружения и удаляет их, когда они обрабатываются. Если точки пересечения обрабатываются с задержкой, размер $Q$ может значительно вырасти. Конечно, его размер всегда ограничен $O(n + I)$, но было бы лучше, если бы объем используемой памяти всегда оставался линейным.  

Существует относительно простой способ добиться этого: хранить только точки пересечения пар отрезков, которые в данный момент смежны на линии сканирования. Алгоритм, описанный выше, также хранит точки пересечения отрезков, которые были горизонтально смежны, но больше не являются таковыми. Храня только пересечения между смежными отрезками, количество точек событий в $Q$ никогда не превышает линейного. Для этого необходимо внести изменения в алгоритм: точка пересечения двух отрезков должна удаляться, когда они перестают быть смежными. Эти отрезки снова станут смежными до достижения точки пересечения, так что она всё равно будет корректно зарегистрирована. Общее время работы алгоритма остаётся $O(n \log n + I \log n)$.  
![[Pasted image 20241211124755.png]]
Мы получаем следующую теорему:  
**Теорема 2.4.** Пусть $S$ — множество из $n$ отрезков на плоскости. Все точки пересечения в $S$, с указанием отрезков, участвующих в каждом пересечении, могут быть найдены за $O(n \log n + I \log n)$ времени и $O(n)$ памяти, где $I$ — количество точек пересечения.  

**2.2 Дважды-связный список рёбер**  
Мы решили самый простой случай задачи наложения карт, когда две карты являются сетями, представленными в виде множества отрезков. В общем случае карты имеют более сложную структуру: они представляют собой разбиение плоскости на помеченные области. Например, тематическая карта лесов Канады может быть разбиением Канады на области с метками, такими как "сосновый", "лиственный", "берёзовый" и "смешанный".  
![[Pasted image 20241211124842.png]]
Прежде чем мы сможем предложить алгоритм для вычисления наложения двух разбиений, нам нужно разработать подходящее представление для разбиения. Хранение разбиения как коллекции отрезков — не очень хорошая идея. Операции, такие как построение границы области, будут довольно сложными. Лучше...
для включения структурной и топологической информации: какие отрезки ограничивают данную область, какие области являются соседними и так далее.  
![[Pasted image 20241211124859.png]]
Рассматриваемые карты представляют собой планарные разбиения, индуцированные планарными вложениями графов. Такое разбиение называется связным, если связным является базовый граф. Вложение узла графа называется вершиной, а вложение дуги — ребром. Мы рассматриваем только такие вложения, где каждое ребро является прямолинейным отрезком. В принципе, рёбра в разбиении не обязаны быть прямолинейными. Разбиение может даже не быть планарным вложением графа, поскольку оно может содержать неограниченные рёбра. Однако в данном разделе мы не рассматриваем такие более общие разбиения.  

Мы считаем, что рёбра открыты, то есть их конечные точки — вершины разбиения — не являются их частью. Лицо разбиения — это максимально связное подмножество плоскости, которое не содержит точек на рёбрах или вершинах. Таким образом, лицо представляет собой открытую многоугольную область, граница которой образована рёбрами и вершинами из разбиения.  

Сложность разбиения определяется как сумма числа вершин, числа рёбер и числа лиц, которые оно содержит. Если вершина является конечной точкой ребра, мы говорим, что вершина и ребро инцидентны. Аналогично, лицо и ребро на его границе, а также лицо и вершина на его границе считаются инцидентными.  

Какие требования должны предъявляться к представлению разбиения? Одной из операций может быть определение лица, содержащего заданную точку. Это действительно полезно в некоторых приложениях — в одной из следующих глав мы разработаем структуру данных для этого. Однако для базового представления это слишком сложная задача.  

Запрашиваемые операции должны быть более локальными. Например, разумно требовать возможность обхода границы данного лица или перехода от одного лица к соседнему через общий ребро. Другой полезной операцией может быть посещение всех рёбер, прилегающих к данной вершине. Представление, которое мы будем обсуждать, поддерживает эти операции. Оно называется дважды-связным списком рёбер.  
![[Pasted image 20241211125041.png]]![[Pasted image 20241211125055.png]]![[Pasted image 20241211125115.png]]
Дважды-связный список рёбер содержит запись для каждого лица, ребра и вершины...
разбиения. Помимо геометрической и топологической информации (которая будет описана далее), каждая запись может содержать дополнительную информацию. Например, если разбиение представляет тематическую карту растительности, в записи каждого лица дважды-связного списка рёбер можно хранить тип растительности соответствующего региона. Эта дополнительная информация называется атрибутивной информацией.  

Геометрическая и топологическая информация, хранящаяся в дважды-связном списке рёбер, должна позволять выполнять базовые операции, упомянутые ранее. Чтобы обойти границу лица в противочасовом направлении, мы храним указатель от каждого ребра к следующему. Полезно также иметь возможность обходить границу лица в другом направлении, поэтому мы храним и указатель на предыдущее ребро.  

Ребро обычно ограничивает два лица, поэтому для него требуется две пары указателей. Удобно рассматривать разные стороны ребра как два различных полу-рёбра, так что для каждого полу-рёбра у нас есть уникальные следующее и предыдущее полу-рёбра. Это также означает, что полу-рёбра ограничивают только одно лицо. Два полу-рёбра, получаемые для данного ребра, называются двойниками.  

Определение следующего полу-рёбра для данного полу-рёбра в соответствии с противочасовым обходом лица задаёт ориентацию каждого полу-рёбра: оно ориентировано так, чтобы лицо, которое оно ограничивает, находилось слева от наблюдателя, идущего вдоль ребра. Благодаря ориентации полу-рёбер мы можем говорить о начале и конце полу-рёбра. Если у полу-рёбра $ \vec{e} $ началом является $v$, а концом — $w$, то у его двойника $Twin(\vec{e})$ началом будет $w$, а концом — $v$.  

Чтобы обойти границу лица, достаточно хранить один указатель в записи лица на произвольное полу-рёбро, ограничивающее это лицо. Начиная с этого полу-рёбра, мы можем шагать от одного полу-рёбра к следующему и обходить лицо.  

Однако это правило не совсем применимо к границам отверстий внутри лица: если они обходятся в противочасовом направлении, то лицо оказывается справа. Удобно ориентировать полу-рёбра так, чтобы лицо всегда находилось с одной и той же стороны. Поэтому мы меняем направление обхода границы отверстия на часовое. Теперь лицо всегда будет слева от любого полу-рёбра на его границе.  

Присутствие отверстий в лице также означает, что одного указателя от лица на произвольное полу-рёбро на его границе недостаточно, чтобы обойти всю границу: нам нужен указатель на полу-рёбро в каждой компоненте границы. Если у лица есть изолированные вершины, не связанные с какими-либо рёбрами, мы можем хранить указатели на них. Для упрощения этот случай можно игнорировать.  

Подведём итоги. Дважды-связный список рёбер состоит из трёх коллекций записей: одной для вершин, одной для лиц и одной для полу-рёбер. Эти записи содержат следующую геометрическую и топологическую информацию:  

- **Запись вершины** $v$ хранит координаты $v$ в поле $Coordinates(v)$, а также указатель $IncidentEdge(v)$ на произвольное полу-рёбро, для которого $v$ является началом.  
- **Запись лица** $f$ хранит указатель $OuterComponent(f)$ на какое-либо полу-рёбро на его внешней границе. Для неограниченного лица этот указатель равен $nil$. Также она содержит список $InnerComponents(f)$, включающий для каждого отверстия в лице указатель на какое-либо полу-рёбро на границе этого отверстия.  
- Запись полу-рёбра $ \vec{e} $ содержит:  

- Указатель $ Origin(\vec{e}) $ на его начальную вершину.  
- Указатель $ Twin(\vec{e}) $ на двойник полу-рёбра.  
- Указатель $IncidentFace(\vec{e})$ на лицо, которое оно ограничивает.  

Нам не нужно хранить конечную вершину ребра, так как она равна $ Origin(Twin(\vec{e})) $. Начало выбирается так, чтобы $ IncidentFace(\vec{e}) $ находилось слева от $ \vec{e} $, если двигаться от начала к концу.  

Запись полу-рёбра также содержит указатели:  
- $ Next(\vec{e}) $ на следующее полу-рёбро на границе $ IncidentFace(\vec{e}) $.  
- $ Prev(\vec{e}) $ на предыдущее полу-рёбро на границе $ IncidentFace(\vec{e}) $.  

Таким образом, $ Next(\vec{e}) $ — это единственное полу-рёбро на границе $ IncidentFace(\vec{e}) $, у которого конец $ \vec{e} $ является началом, а $ Prev(\vec{e}) $ — единственное полу-рёбро, у которого начало $ \vec{e} $ является концом.  

Каждая вершина и ребро используют фиксированное количество памяти. Лица могут требовать больше памяти, так как список $ InnerComponents(f) $ содержит столько элементов, сколько отверстий в лице. Поскольку любое полу-рёбро указывается не более одного раза всеми списками $ InnerComponents(f) $, общий объём памяти линеен относительно сложности разбиения.  

Пример дважды-связного списка рёбер для простого разбиения: два полу-рёбра, соответствующие ребру $ e_i $, обозначаются $ \vec{e}_{i,1} $ и $ \vec{e}_{i,2} $.  
![[Pasted image 20241211125426.png]]
Хранимая информация позволяет выполнять основные операции. Например:  
- Мы можем обойти внешнюю границу лица $ f $, следуя указателям $ Next(\vec{e}) $, начиная с полу-рёбра $ OuterComponent(f) $.  
- Мы можем посетить все рёбра, инцидентные вершине $ v $.  

Упражнение: попробуйте самостоятельно разобраться, как выполнить эти операции.  

Мы описали довольно общий вариант дважды-связного списка рёбер. В приложениях, где вершины не содержат атрибутивной информации, можно хранить их координаты прямо в поле $ Origin() $ полу-рёбра, не создавая отдельную запись для вершины.  

Важно отметить, что в некоторых приложениях лица разбиения не несут интересной информации (например, в сетях рек или дорог). В таких случаях можно полностью исключить записи для лиц и поле $ IncidentFace() $ из полу-рёбер.  

Некоторые реализации дважды-связного списка рёбер могут требовать, чтобы граф, сформированный вершинами и рёбрами разбиения, был связным. Это можно обеспечить добавлением фиктивных рёбер, что имеет два преимущества:  
1. Можно использовать простой обход графа для посещения всех полу-рёбер.  
2. Список $ InnerComponents() $ для лиц становится ненужным.  
### 2.3 Вычисление пересечения двух разбиений

Теперь, когда у нас есть удобное представление разбиения, мы можем решить общую задачу наложения карт. Мы определяем пересечение двух разбиений $ S_1 $ и $ S_2 $ как разбиение $ O(S_1, S_2) $, такое, что лицо $ f $ входит в $ O(S_1, S_2) $ тогда и только тогда, когда существуют лица $ f_1 $ в $ S_1 $ и $ f_2 $ в $ S_2 $, для которых $ f $ — это максимальное связное подмножество $ f_1 \cap f_2 $.  

Это звучит сложнее, чем есть на самом деле: пересечение представляет собой разбиение плоскости, индуцированное рёбрами из $ S_1 $ и $ S_2 $. На рисунке 2.4 это проиллюстрировано. Задача общего наложения карт состоит в том, чтобы вычислить дважды-связный список рёбер для $ O(S_1, S_2) $, имея дважды-связные списки рёбер для $ S_1 $ и $ S_2 $.  

Мы требуем, чтобы каждое лицо в $ O(S_1, S_2) $ было помечено метками лиц из $ S_1 $ и $ S_2 $, которые его содержат. Это позволяет нам получить доступ к атрибутивной информации, хранимой для этих лиц. Например, в наложении карты растительности и карты осадков это обеспечит информацию о типе растительности и количестве осадков для каждой области пересечения.  
![[Pasted image 20241211125509.png]]
Сначала рассмотрим, какую информацию из дважды-связных списков рёбер $ S_1 $ и $ S_2 $ можно переиспользовать в списке для $ O(S_1, S_2) $. Рассмотрим сеть рёбер и вершин из $ S_1 $. Эта сеть разрезается рёбрами из $ S_2 $ на части. Большинство таких частей можно переиспользовать; только те рёбра, которые были разрезаны рёбрами $ S_2 $, должны быть обновлены. Но распространяется ли это Рассмотрим, сохраняются ли описанные свойства для записей о полурёбрах в дважды-связном списке рёбер, соответствующих разрезанным частям. Если бы ориентация полурёбра изменилась, информацию в этих записях пришлось бы менять. К счастью, это не так. Полурёбра ориентированы так, чтобы грань, которую они ограничивают, находилась слева. Форма грани может измениться при наложении, но она всё равно будет находиться с той же стороны от полурёбра.  

Таким образом, можно повторно использовать записи о полурёбрах, соответствующие рёбрам, которые не пересекаются рёбрами с другой карты. Иными словами, единственные записи о полурёбрах в дважды-связном списке рёбер для $ O(S_1, S_2) $, которые нельзя заимствовать из $ S_1 $ или $ S_2 $, — это те, которые инцидентны точкам пересечения рёбер с разных карт.  

### Подход к решению

Первым шагом будет копирование дважды-связных списков рёбер $ S_1 $ и $ S_2 $ в новый дважды-связный список рёбер. Новый список, разумеется, не является корректным дважды-связным списком рёбер, поскольку пока он не представляет собой планарное разбиение. Задача алгоритма наложения состоит в преобразовании списка в корректный дважды-связный список рёбер для $ O(S_1, S_2) $ путём вычисления точек пересечения между двумя сетями рёбер и связывания соответствующих частей двух списков.  

Информация о новых записях граней сложнее для вычисления, поэтому мы оставим это на потом. Сначала мы более подробно опишем, как вычисляются записи о вершинах и полурёбрах в дважды-связном списке рёбер для $ O(S_1, S_2) $.  

Алгоритм основывается на методе "сканирующей прямой" (plane sweep), описанном в разделе 2.1 для вычисления пересечений набора отрезков. Мы применяем его к объединённому набору рёбер из $ S_1 $ и $ S_2 $, считая рёбра замкнутыми.  

Для поддержки алгоритма используются две структуры данных:
1. **Очередь событий $ Q $**, хранящая точки событий.
2. **Структура состояния $ T $**, представляющая собой сбалансированное бинарное дерево поиска, содержащее отрезки, пересекающие сканирующую прямую, упорядоченные слева направо.  

Дополнительно мы поддерживаем дважды-связный список рёбер $ D $. Изначально $ D $ содержит копии дважды-связных списков рёбер $ S_1 $ и $ S_2 $. Во время работы алгоритма $ D $ будет преобразовываться в корректный дважды-связный список рёбер для $ O(S_1, S_2) $ с учётом вершин и полурёбер; информация о гранях будет добавлена позже.  

Мы поддерживаем перекрёстные указатели между рёбрами в $ T $ и записями о полурёбрах в $ D $, чтобы получить доступ к частям $ D $, которые нужно изменить при обнаружении точки пересечения. Инвариант, который мы поддерживаем: на любой момент времени часть наложения выше сканирующей прямой вычислена корректно.  

### Действия при достижении точки события

При достижении точки события:
1. Мы обновляем $ T $ и $ Q $ так же, как в алгоритме поиска пересечений отрезков.
2. Если событие включает только рёбра из одного разбиения, больше ничего делать не нужно; точка события является вершиной, которую можно повторно использовать.
3. Если событие включает рёбра из обоих разбиений, нужно внести локальные изменения в $ D $, чтобы связать дважды-связные списки рёбер исходных разбиений в точке пересечения.  

Эти изменения трудоёмки, но несложны.  
![[Pasted image 20241211125926.png]]
### Детали алгоритма для конкретного случая

Рассмотрим один из возможных случаев: ребро $e$ из $S_1$ проходит через вершину $v$ из $S_2$ (см. рисунок 2.5). Ребро $e$ должно быть заменено на два новых ребра, обозначенных как $e'$ и $e''$. В дважды-связном списке рёбер два полурёбра для $e$ превращаются в четыре.  

Создаются две новые записи о полурёбрах, обе с $v$ в качестве начальной вершины. Два существующих полурёбра для $e$ сохраняют начальные точки $e$ в качестве своих начальных вершин (как показано на рисунке 2.5). Затем существующие полурёбра связываются с новыми полурёбрами через указатели $Twin()$. Таким образом, $e'$ представлено одним новым и одним существующим полурёбром, и то же самое справедливо для $e''$.  

#### Установка указателей $Prev()$ и $Next()$

Сначала исправляем ситуацию вокруг конечных точек $e$. Указатели $Next()$ для двух новых полурёбер копируют значения указателей $Next()$ от старых полурёбер, которые не являются их близнецами. Полурёбра, на которые указывают эти указатели, также должны обновить свои указатели $Prev()$, установив их на новые полурёбра. Корректность этого шага легче всего проверить, взглянув на схему.  

Теперь исправляем ситуацию вокруг вершины $v$. Устанавливаем указатели $Next()$ и $Prev()$ для четырёх полурёбер, представляющих $e'$ и $e''$, а также для четырёх полурёбер, инцидентных $v$ из $S_2$. Эти четыре полурёбра из $S_2$ определяются путём проверки, где $e'$ и $e''$ должны располагаться в циклическом порядке рёбер вокруг вершины $v$.  

Существуют четыре пары полурёбер, которые связываются через указатели $Next()$ и $Prev()$. Рассмотрим полуребро для $e'$, имеющее $v$ в качестве конечной точки. Оно должно быть связано с первым полуребром, который встречается по часовой стрелке от $e'$, с $v$ в качестве начальной точки. Полуребро для $e'$, имеющее $v$ в качестве начальной точки, должно быть связано с первым против часовой стрелки полуребром, имеющим $v$ в качестве конечной точки. Те же самые утверждения справедливы для $e''$.  

#### Оценка временной сложности

Большинство описанных шагов занимают только постоянное время. Лишь определение положения $e'$ и $e''$ в циклическом порядке вокруг $v$ может занять больше времени — пропорционально степени вершины $v$.  

Другие возможные случаи — пересечение двух рёбер из разных карт или совпадение вершин — не сложнее рассмотренного выше. Эти случаи также требуют $O(m)$ времени, где $m$ — количество рёбер, инцидентных точке события.  

Таким образом, обновление $D$ асимптотически не увеличивает время работы алгоритма пересечения отрезков. Заметим, что каждая найденная точка пересечения становится вершиной наложения. Это означает, что записи о вершинах и полурёбрах в дважды-связном списке рёбер для $O(S_1, S_2)$ могут быть вычислены за время $O(n \log n + k \log n)$, где $n$ обозначает сумму сложностей $S_1$ и $S_2$, а $k$ — сложность наложения.  
![[Pasted image 20241211130008.png]]![[Pasted image 20241211130018.png]]
### Определение информации о гранях наложения $O(S_1, S_2)$

![[Pasted image 20241211130110.png]]
После заполнения полей, связанных с вершинами и полурёбрами, остаётся вычислить информацию о гранях наложения $O(S_1, S_2)$. Нам нужно создать запись о грани для каждой грани $f$ в $O(S_1, S_2)$, установить указатель $OuterComponent(f)$ на полуребро, находящееся на внешней границе $f$, и сформировать список $InnerComponents(f)$ с указателями на полурёбра, образующие границы дыр внутри $f$.  

Также необходимо установить поля $IncidentFace()$ для полурёбер на границе $f$, чтобы они указывали на запись грани $f$. Кроме того, каждая новая грань должна быть помечена именами граней из старых разбиений, которые её содержат.

#### Определение числа записей о гранях

За исключением неограниченной грани, каждая грань имеет уникальную внешнюю границу. Таким образом, количество записей о гранях равно количеству внешних границ плюс одна. Из построенной части дважды-связного списка рёбер можно легко извлечь все циклы границ.  

Чтобы определить, является ли цикл внешней границей или границей дыры, анализируется самая левая вершина $v$ цикла. В случае совпадений выбирается нижняя из самых левых. Полурёбра направлены так, что инцидентная грань локально находится слева. Рассматривая два полуребра цикла, инцидентных $v$, можно вычислить угол между ними внутри инцидентной грани. Если угол меньше $180^\circ$, то цикл является внешней границей, иначе — границей дыры.

#### Построение графа $G$

Для определения, какие граничные циклы принадлежат одной грани, строится граф $G$.  
- Каждому граничному циклу (внешнему и внутреннему) соответствует узел в $G$.  
- Узел также создаётся для воображаемой внешней границы неограниченной грани.  
- Ребро соединяет два цикла, если один из них является границей дыры, а у другого есть полуребро слева от самой левой вершины цикла дыры. Если такого полуребра нет, узел цикла связывается с узлом неограниченной грани.  

#### Лемма 2.5

Каждая связная компонента графа $G$ соответствует набору циклов, инцидентных одной грани.  
![[Pasted image 20241211130131.png]]
**Доказательство:**  
Пусть $C$ — цикл, ограничивающий дыру в грани $f$. Так как $f$ находится слева от самой левой вершины $C$, $C$ должен быть связан с другим циклом, который также ограничивает $f$. Это означает, что циклы в одной связной компоненте $G$ ограничивают одну и ту же грань.  

Теперь покажем, что любой цикл, ограничивающий дыру в $f$, находится в одной связной компоненте с внешней границей $f$. Предположим, существует цикл $C$, для которого это не выполняется. Пусть $C$ — самый левый такой цикл. По определению, существует дуга между $C$ и другим циклом $C'$, который частично расположен слева от самой левой вершины $C$. Следовательно, $C'$ принадлежит той же связной компоненте, что и $C$, но не компоненте внешней границы $f$. Это противоречит определению $C$.
![[Pasted image 20241211130335.png]]
#### Построение информации о гранях

После построения графа $G$ для каждой связной компоненты создаётся запись о грани. Указатели $IncidentFace()$ для полурёбер, ограничивающих грань $f$, устанавливаются на запись грани $f$. Список $InnerComponents(f)$ и множество $OuterComponent(f)$ также формируются.  

	Построение $G$ выполняется за $O(n + k)$ времени, где $n$ — сумма сложностей $S_1$ и $S_2$, а $k$ — сложность наложения. Эта информация вычисляется после алгоритма "плоского сканирования".  
### Присвоение меток граням наложения $O(S_1, S_2)$
![[Pasted image 20241211130901.png]]
Необходимо пометить каждую грань $f$ в наложении именами граней из исходных разбиений, которые её содержат. Для этого рассматриваем произвольную вершину $v$ грани $f$.  

Если $v$ — это пересечение рёбер $e_1$ из $S_1$ и $e_2$ из $S_2$, то можно определить, какие грани $S_1$ и $S_2$ содержат $f$, используя указатель $IncidentFace()$ для соответствующих полурёбер $e_1$ и $e_2$. Если $v$ — не пересечение, а вершина, например, из $S_1$, то известна только грань $S_1$, содержащая $f$. Чтобы найти грань $S_2$, содержащую $f$, нужно определить грань $S_2$, содержащую $v$.  

Если для каждой вершины $S_1$ известно, в какой грани $S_2$ она находится, и наоборот, то можно правильно пометить грани наложения $O(S_1, S_2)$. Для этого используется алгоритм "плоского сканирования" (plane sweep), описанный ранее.

### Алгоритм наложения разбиений

**Ввод:** Два планарных разбиения $S_1$ и $S_2$, представленных дважды-связными списками рёбер.  
**Вывод:** Наложение $S_1$ и $S_2$, представленное дважды-связным списком рёбер $D$.

1. Скопируйте дважды-связные списки рёбер $S_1$ и $S_2$ в новый список $D$.
2. Найдите все пересечения рёбер из $S_1$ и $S_2$ с помощью алгоритма "плоского сканирования" (раздел 2.1). На каждом событии:  
   - Обновите $D$, как описано выше, если событие связано с рёбрами из $S_1$ и $S_2$.  
   - Сохраните полуребро, находящееся непосредственно слева от точки события, в вершине $D$, представляющей эту точку.  

3. (На этом этапе $D$ — это дважды-связный список рёбер для $O(S_1, S_2)$, но информация о гранях ещё не заполнена.)  
4. Определите граничные циклы в $O(S_1, S_2)$, обходя список $D$.  
5. Постройте граф $G$, узлы которого соответствуют граничным циклам, а дуги соединяют каждый цикл дыры с циклом, расположенным слева от его самой левой вершины. Найдите связные компоненты $G$.  

6. Для каждой связной компоненты $G$:  
   - Определите уникальный внешний граничный цикл $C$ в компоненте.  
   - Создайте запись грани $f$, установите $OuterComponent(f)$ на полуребро из $C$ и сформируйте список $InnerComponents(f)$, содержащий указатели на одно полуребро из каждого цикла дыры в компоненте.  
   - Установите указатели $IncidentFace()$ всех полурёбер в циклах на запись грани $f$.  

7. Пометьте каждую грань $O(S_1, S_2)$ именами граней $S_1$ и $S_2$, которые её содержат.  

### Теорема 2.6

Пусть $S_1$ — планарное разбиение сложности $n_1$, $S_2$ — разбиение сложности $n_2$, а $n := n_1 + n_2$. Наложение $S_1$ и $S_2$ можно построить за время $O(n \log n + k \log n)$, где $k$ — сложность наложения.

**Доказательство:**  
- Копирование дважды-связных списков рёбер (шаг 1) занимает $O(n)$.  
- Алгоритм "плоского сканирования" (шаг 2) работает за $O(n \log n + k \log n)$ (Лемма 2.3).  
- Шаги 4–7, где заполняются записи о гранях, требуют времени, линейного сложности $O(S_1, S_2)$.  
- Наконец, пометка каждой грани (шаг 7) также занимает $O(n \log n + k \log n)$.  

### 2.4 Булевы операции над многоугольниками

Алгоритм наложения карт является мощным инструментом, который можно использовать для различных задач. Одна из особенно полезных задач — выполнение булевых операций объединения, пересечения и разности над двумя многоугольниками $P_1$ и $P_2$. Пример показан на рисунке 2.7. Обратите внимание, что результат операций может уже не быть многоугольником — он может состоять из нескольких многоугольных областей, некоторые из которых содержат дыры.
![[Pasted image 20241211131049.png]]
Чтобы выполнить булеву операцию, рассматриваем многоугольники как планарные карты, ограниченные грани которых помечены как $P_1$ и $P_2$, соответственно. Мы вычисляем наложение этих карт и извлекаем грани из наложения, метки которых соответствуют заданной булевой операции.  

- Для вычисления пересечения $P_1 \cap P_2$ извлекаются грани из наложения, помеченные как $P_1$ и $P_2$.  
- Для вычисления объединения $P_1 \cup P_2$ извлекаются грани из наложения, помеченные как $P_1$ или $P_2$.  
- Для вычисления разности $P_1 \setminus P_2$ извлекаются грани из наложения, помеченные как $P_1$, но не $P_2$.

Поскольку каждая точка пересечения ребра $P_1$ и ребра $P_2$ становится вершиной $P_1 \cap P_2$, время работы алгоритма составляет $O(n \log n + k \log n)$, где $n$ — общее количество вершин в $P_1$ и $P_2$, а $k$ — сложность $P_1 \cap P_2$. Это также справедливо для других булевых операций: любая точка пересечения двух рёбер становится вершиной конечного результата, независимо от выбранной операции.

Таким образом, получаем следующий результат.

[Следствие 2.7] Пусть $P_1$ — многоугольник с $n_1$ вершинами, а $P_2$ — многоугольник с $n_2$ вершинами, и пусть $n := n_1 + n_2$. Тогда $P_1 \cap P_2$, $P_1 \cup P_2$ и $P_1 \setminus P_2$ можно вычислить за время $O(n \log n + k \log n)$, где $k$ — сложность результата.

### 2.5 Примечания и комментарии

Задача о пересечении отрезков является одной из фундаментальных задач вычислительной геометрии. Решение с временной сложностью $O(n \log n + k \log n)$, представленное в этой главе, было предложено Бентли и Оттманом [47] в 1979 году. (Несколькими годами ранее, Шамос и Хой [351] решили задачу обнаружения, в которой требуется только определить, существует ли хотя бы одно пересечение, за время $O(n \log n)$.) Метод уменьшения используемой памяти с $O(n + k)$ до $O(n)$, описанный в этой главе, взят из работы Пача и Шарира [312], которые также показали, что размер списка событий может достигать $\Omega(n \log n)$ до этой оптимизации. Браун [77] описал альтернативный метод для достижения такого уменьшения.

Нижняя граница для задачи о нахождении всех пересечений отрезков составляет $\Omega(n \log n + k)$, поэтому алгоритм на основе метода "plane sweep", описанный в этой главе, не является оптимальным при большом $k$. Первый шаг к созданию оптимального алгоритма был сделан Чазеллем [88], который предложил алгоритм с временной сложностью $O(n \log^2 n / \log \log n + k)$. В 1988 году Чазелль и Эдельсбруннер [99, 100] представили первый алгоритм с временной сложностью $O(n \log n + k)$. Однако он требует $O(n + k)$ памяти. Позднее Кларксон и Шор [133] и Мулмулей [288] предложили рандомизированные инкрементальные алгоритмы с ожидаемым временем работы $O(n \log n + k)$. (Подробнее о рандомизированных алгоритмах см. в главе 4.) Используемая память у этих алгоритмов составляет $O(n)$ и $O(n + k)$ соответственно. В отличие от алгоритма Чазелля и Эдельсбруннера, эти рандомизированные алгоритмы также работают для нахождения пересечений в множестве кривых. Балабан [35] представил первый детерминированный алгоритм для задачи пересечения отрезков, который работает за $O(n \log n + k)$ времени и использует $O(n)$ памяти. Этот алгоритм также подходит для кривых.

Существуют случаи задачи о пересечении отрезков, которые проще общего случая. Один из таких случаев — наличие двух множеств отрезков, например, красных и синих, где никакие два отрезка из одного множества не пересекаются. (Этот случай, по сути, совпадает с задачей наложения сетей. Однако в решении, описанном в этой главе, факт принадлежности отрезков к двум непересекающимся множествам не использовался.) Так называемая задача о пересечении красно-синих отрезков была решена за время $O(n \log n + k)$.

и $O(n)$ память, предложенная Мейрсоном и Стольфи [262], до того как общая задача была решена оптимально. Другие оптимальные алгоритмы для пересечений красно-синих отрезков были предложены Чазеллем и соавторами [101] и Палацци и Снойинком [315]. Если два множества отрезков образуют связанные разбиения, ситуация еще лучше: в этом случае наложение можно вычислить за время $O(n + k)$, как показали Финке и Хинрихс [176]. Их результат обобщает и улучшает предыдущие результаты по наложению карт, полученные Нивергельтом и Препарата [293], Гибасом и Сейделем [200], а также Мейрсоном и Стольфи [262].

Задача подсчета пересечений отрезков заключается в определении количества точек пересечения в наборе из $n$ отрезков. Поскольку результатом является одно целое число, то термин с $k$ в оценке времени больше не относится к размеру вывода (который является постоянным), а только к числу пересечений. Алгоритмы, которые не зависят от числа пересечений, имеют временную сложность $O(n^{4/3} \log^c n)$ для некоторой малой константы $c$ [4, 95]; время, близкое к $O(n \log n)$, пока не найдено.

Метод "plane sweep" является одним из самых важных парадигм для проектирования геометрических алгоритмов. Первые алгоритмы в вычислительной геометрии, основанные на этой парадигме, были предложены Шамосом и Хоем [351], Ли и Препарата [250], а также Бентли и Оттманом [47]. Алгоритмы "plane sweep" особенно подходят для нахождения пересечений в наборах объектов, но их также можно использовать для решения многих других задач. В главе 3 метод "plane sweep" решает часть задачи триангуляции многоугольника, а в главе 7 мы увидим алгоритм "plane sweep" для вычисления так называемой диаграммы Вороного для набора точек. Алгоритм, представленный в текущей главе, перемещает горизонтальную линию вниз по плоскости. Для некоторых задач более удобно использовать другой способ сканирования плоскости. Например, мы можем сканировать плоскость с помощью вращающейся линии — см. главу 15 для примера — или с помощью псевдолинии (линии, которая не обязана быть прямой, но ведет себя как линия) [159]. Техника "plane sweep" также может быть использована в более высоких измерениях: в этом случае мы сканируем пространство гиперплоскостью [213, 311, 324]. Такие алгоритмы называются алгоритмами сканирования пространства.

В этой главе мы описали структуру данных для хранения разбиений: дважды связанный список рёбер. Эта структура, или, точнее, её вариант, была описана Мюллером и Препарата [286]. Существуют и другие структуры данных для хранения разбиений, такие как структура крылатых рёбер Баумгарта [40] и структура квадро-ребра Гибаса и Стольфи [202]. Различия между этими структурами незначительны. Все они имеют примерно одинаковую функциональность, но некоторые экономят несколько байтов памяти на каждое ребро.
![[Pasted image 20241211131215.png]]![[Pasted image 20241211131227.png]]

### 2.6 Exercises
2.13
![[Pasted image 20241211131257.png]]
2.14
![[Pasted image 20241211131321.png]]


## 3 Polygon Triangulation

### Guarding an Art Gallery

[54]

![[Pasted image 20241211131405.png]]
Днем дежурные могут вести наблюдение, но ночью это должны делать
видеокамеры. Эти камеры обычно подвешиваются к потолку и
вращаются вокруг вертикальной оси. Изображения с камер отправляются на
телевизоры в офисе ночного дежурного. Поскольку легче следить за
несколькими телевизорами, чем за многими, количество камер должно быть
как можно меньше. Дополнительным преимуществом небольшого количества камер является то,
что стоимость системы безопасности будет ниже. С другой стороны, у нас не может быть
слишком мало камер, потому что каждая часть галереи должна быть видна по крайней мере
одной из них. Поэтому мы должны размещать камеры в стратегических позициях,
таким образом, чтобы
каждая из них охраняла большую часть галереи. Это приводит к тому, что обычно
называют «проблемой художественной галереи»: сколько камер нам нужно для охраны
данной галереи и как мы решаем, где их разместить?
![[Pasted image 20241211131417.png]]

[46]
### 3.1 Охрана и триангуляция  
Если мы хотим более точно определить задачу галереи искусства, нам сначала следует формализовать понятие галереи. Галерея, конечно, является трехмерным пространством, но план этажа дает нам достаточно информации для размещения камер. Поэтому мы моделируем галерею как многоугольную область на плоскости. Мы также ограничиваемся областями, которые являются простыми многоугольниками, то есть областями, ограниченными единственной замкнутой многоугольной цепью, которая не пересекает саму себя. Таким образом, мы не допускаем областей с отверстиями. Положение камеры в галерее соответствует точке внутри многоугольника. Камера видит те точки внутри многоугольника, с которыми ее можно соединить открытым отрезком, лежащим внутри многоугольника.

Сколько камер нужно, чтобы охранять простой многоугольник? Это явно зависит от самого многоугольника: чем сложнее форма многоугольника, тем больше камер потребуется. Поэтому мы будем выражать верхнюю границу на количество необходимых камер в терминах $n$, числа вершин многоугольника. Но даже если два многоугольника имеют одинаковое количество вершин, один из них может быть легче для охраны, чем другой. Например, выпуклый многоугольник всегда можно охранять одной камерой. Чтобы подстраховаться, мы рассмотрим наихудший сценарий, то есть дадим оценку, которая будет справедливой для любого простого многоугольника с $n$ вершинами. (Было бы замечательно, если бы мы могли найти минимальное количество камер для данного многоугольника, а не только верхнюю границу. К сожалению, задача нахождения минимального числа камер для данного многоугольника является NP-трудной.)  

Пусть $\mathcal{P}$ — простой многоугольник с $n$ вершинами. Поскольку $\mathcal{P}$ может быть сложной формы, кажется трудным что-либо сказать о количестве камер, необходимых для охраны $\mathcal{P}$. Поэтому сначала мы разложим $\mathcal{P}$ на части, которые легко охранять, а именно на треугольники. Для этого мы проведем диагонали между парами вершин.

![[Pasted image 20241211131437.png]]![[Pasted image 20241211131452.png]]
### Диагонали и триангуляция  
Диагональ — это открытый отрезок, который соединяет две вершины $\mathcal{P}$ и лежит внутри $\mathcal{P}$. Разбиение многоугольника на треугольники максимальным набором непересекающихся диагоналей называется триангуляцией многоугольника — см. Рисунок 3.2. (Мы требуем, чтобы набор непересекающихся диагоналей был максимальным, чтобы ни один треугольник не имел вершины многоугольника внутри одной из своих сторон. Это могло бы произойти, если бы у многоугольника было три последовательные коллинеарные вершины.)  
Триангуляции обычно не уникальны; многоугольник на Рисунке 3.2, например, можно триангулировать многими способами. Мы можем охранять $\mathcal{P}$, размещая камеру в каждом треугольнике триангуляции $T_\mathcal{P}$ многоугольника $\mathcal{P}$. Но всегда ли существует триангуляция? И сколько треугольников может быть в триангуляции? На эти вопросы отвечает следующая теорема.



[47]

#### **Теорема 3.1**  
Любой простой многоугольник допускает триангуляцию, и любая триангуляция простого многоугольника с $n$ вершинами состоит ровно из $n - 2$ треугольников.  

**Доказательство.**  
Докажем эту теорему методом математической индукции по $n$. Когда $n = 3$, сам многоугольник является треугольником, и теорема тривиально выполняется. Пусть $n > 3$, и предположим, что теорема верна для всех $m < n$. Пусть $\mathcal{P}$ — многоугольник с $n$ вершинами. Сначала докажем существование диагонали в $\mathcal{P}$. Пусть $v$ — самая левая вершина $\mathcal{P}$. (В случае равенства выбираем нижнюю из левых вершин.) Пусть $u$ и $w$ — две соседние вершины $v$ на границе $\mathcal{P}$. Если открытый отрезок $uw$ лежит внутри $\mathcal{P}$, то мы нашли диагональ. В противном случае внутри треугольника, определяемого $u$, $v$ и $w$, или на диагонали $uw$ находится одна или несколько вершин. Пусть $v'$ — вершина, наиболее удалённая от прямой, проходящей через $u$ и $w$. Отрезок, соединяющий $v$ и $v'$, не может пересекать ребро $\mathcal{P}$, потому что такое ребро имело бы конечную точку внутри треугольника, более удалённую от линии $uw$, что противоречит определению $v'$. Следовательно, $vv'$ — диагональ.  

Итак, диагональ существует. Любая диагональ делит $\mathcal{P}$ на два простых подмногоугольника $\mathcal{P}_1$ и $\mathcal{P}_2$. Пусть $m_1$ — количество вершин в $\mathcal{P}_1$, а $m_2$ — количество вершин в $\mathcal{P}_2$. Оба значения $m_1$ и $m_2$ меньше $n$, так что по предположению индукции $\mathcal{P}_1$ и $\mathcal{P}_2$ допускают триангуляцию. Следовательно, $\mathcal{P}$ тоже допускает триангуляцию.  

Остаётся доказать, что любая триангуляция $\mathcal{P}$ состоит из $n - 2$ треугольников. Для этого рассмотрим произвольную диагональ в какой-либо триангуляции $T_\mathcal{P}$. Эта диагональ делит $\mathcal{P}$ на два подмногоугольника с $m_1$ и $m_2$ вершинами, соответственно. Каждая вершина $\mathcal{P}$ появляется ровно в одном из двух подмногоугольников, за исключением вершин, определяющих диагональ, которые появляются в обоих подмногоугольниках. Следовательно, $m_1 + m_2 = n + 2$. По индукции любая триангуляция $\mathcal{P}_i$ состоит из $m_i - 2$ треугольников, что означает, что $T_\mathcal{P}$ состоит из $(m_1 - 2) + (m_2 - 2) = n - 2$ треугольников.  

Теорема 3.1 подразумевает, что любой простой многоугольник с $n$ вершинами можно охранять с помощью $n - 2$ камер. Но размещение камеры внутри каждого треугольника кажется избыточным. Камера, установленная на диагонали, например, будет охранять два треугольника, поэтому, размещая камеры на хорошо выбранных диагоналях, мы могли бы сократить количество камер примерно до $n / 2$. Размещение камер в вершинах выглядит ещё лучше, потому что вершина может быть общей для многих треугольников, а камера в этой вершине охраняет их все. Это предполагает следующий подход.  

Пусть $T_\mathcal{P}$ — триангуляция $\mathcal{P}$. Выберем подмножество вершин $\mathcal{P}$ так, чтобы каждый треугольник в $T_\mathcal{P}$ имел хотя бы одну выбранную вершину, и разместим камеры в выбранных вершинах. Чтобы найти такое подмножество, мы назначим каждой вершине $\mathcal{P}$ один из трёх цветов: белый, серый или чёрный. Такое раскрашивание будет таким, что любые две вершины, соединённые ребром или диагональю, имеют разные цвета. Это называется 3-раскраской триангулированного многоугольника. В 3-раскраске каждый треугольник имеет белую, серую и чёрную вершину. Следовательно, если мы разместим камеры, например, во всех серых вершинах, то охраним весь многоугольник. Выбирая наименьший класс цветов для размещения камер, мы можем охранять $\mathcal{P}$, используя не более $\lfloor n / 3 \rfloor$ камер.  

Но всегда ли существует 3-раскраска? Ответ — да. Чтобы это доказать, мы рассмотрим так называемый двойственный граф триангуляции $T_\mathcal{P}$. Этот граф $G(T_\mathcal{P})$ имеет узел для каждого треугольника в $T_\mathcal{P}$. Мы обозначаем треугольник, соответствующий узлу $\nu$, как $t(\nu)$. Узлы $\nu$ и $\mu$ соединены дугой, если $t(\nu)$ и $t(\mu)$ имеют общую диагональ.  

![[Pasted image 20241211131627.png]]
![[Pasted image 20241211131634.png]]
![[Pasted image 20241211131644.png]]
[48]
В графе $G(T_\mathcal{P})$ ребра соответствуют диагоналям в $T_\mathcal{P}$. Поскольку любая диагональ делит $\mathcal{P}$ на две части, удаление ребра из $G(T_\mathcal{P})$ разделяет граф на две части. Следовательно, $G(T_\mathcal{P})$ является деревом. (Обратите внимание, что это не выполняется для многоугольников с отверстиями.) Это означает, что мы можем выполнить 3-раскраску, используя простой обход графа, например, поиск в глубину. Далее мы опишем, как это сделать.  

Во время выполнения поиска в глубину мы поддерживаем следующий инвариант: все вершины уже рассмотренных треугольников окрашены в белый, серый или чёрный цвет, и никакие две соединённые вершины не имеют одинакового цвета. Этот инвариант гарантирует, что после обработки всех треугольников у нас будет корректная 3-раскраска. Поиск в глубину можно начать с любой вершины графа $G(T_\mathcal{P})$; три вершины соответствующего треугольника окрашиваются в белый, серый и чёрный цвета. Теперь предположим, что мы достигаем узла $\nu$ в $G$, приходя из узла $\mu$. Следовательно, $t(\nu)$ и $t(\mu)$ имеют общую диагональ. Поскольку вершины $t(\mu)$ уже окрашены, остаётся закрасить только одну вершину $t(\nu)$. Для этой вершины остаётся один доступный цвет — тот, который не используется для вершин диагонали между $t(\nu)$ и $t(\mu)$. Поскольку $G(T_\mathcal{P})$ является деревом, другие узлы, смежные с $\nu$, ещё не были посещены, и мы можем свободно присвоить оставшийся цвет вершине.  

Мы делаем вывод, что триангулированный простой многоугольник всегда можно 3-окрасить. Следовательно, любой простой многоугольник можно охранять с помощью $\lfloor n/3 \rfloor$ камер. Однако, возможно, можно добиться ещё большего. Ведь камера, размещённая в вершине, может охранять не только инцидентные треугольники. К сожалению, для любого $n$ существуют простые многоугольники, которые требуют ровно $\lfloor n/3 \rfloor$ камер. Примером является многоугольник в форме "гребёнки" с длинным горизонтальным основанием и $\lfloor n/3 \rfloor$ "зубьями", каждый из которых состоит из двух рёбер. Зубья соединены горизонтальными рёбрами. Конструкция может быть выполнена так, чтобы не существовало позиции камеры, из которой можно было бы охватить более одного зуба одновременно. Таким образом, нельзя надеяться на стратегию, которая всегда использует меньше, чем $\lfloor n/3 \rfloor$ камер. Другими словами, метод 3-раскраски является оптимальным в худшем случае.  

Мы только что доказали Теорему об охране галереи, классический результат из комбинаторной геометрии.  

**Теорема 3.2 (Теорема об охране галереи)**  
Для простого многоугольника с $n$ вершинами $\lfloor n/3 \rfloor$ камер иногда требуется и всегда достаточно, чтобы каждая точка внутри многоугольника была видна хотя бы с одной камеры.  

Теперь мы знаем, что $\lfloor n/3 \rfloor$ камер всегда достаточно. Однако у нас пока нет эффективного алгоритма для вычисления позиций камер. Нам нужен быстрый алгоритм триангуляции простого многоугольника. Этот алгоритм должен предоставлять подходящее представление триангуляции, например, двусвязный список рёбер, чтобы мы могли за постоянное время переходить от одного треугольника к его соседям. Имея такое представление, мы можем вычислить множество из не более чем $\lfloor n/3 \rfloor$ позиций камер за линейное время, используя описанный выше метод: выполнить поиск в глубину по двойственному графу, чтобы вычислить 3-раскраску, и выбрать наименьший цветовой класс для размещения камер. В следующих разделах мы опишем, как вычислить триангуляцию за время $O(n \log n)$. Предвосхищая это, мы уже формулируем окончательный результат об охране многоугольника.  
![[Pasted image 20241211131706.png]]
![[Pasted image 20241211131712.png]]

[49]
Theorem 3.3 Let P be a simple polygon with n vertices. A set of ⌊n/3⌋ camera

positions in P such that any point inside P is visible from at least one of the

cameras can be computed in O(n logn) time.

### 3.2 Partitioning a Polygon into Monotone Pieces

![[Pasted image 20241211131752.png]]
![[Pasted image 20241211131759.png]]
![[Pasted image 20241211131807.png]]
# [50]

![[Pasted image 20241211131835.png]]

Lemma 3.4

# [51]

![[Pasted image 20241211132711.png]]
# [52]

![[Pasted image 20241211132732.png]]
![[Pasted image 20241211132740.png]]
# [53]
# [54]
![[Pasted image 20241211132925.png]]
# [55]
![[Pasted image 20241211132935.png]]
### 3.3 Triangulating a Monotone Polygon

# [56]
![[Pasted image 20241211132957.png]]![[Pasted image 20241211133002.png]]
# [57]
![[Pasted image 20241211133014.png]]
# [58]
![[Pasted image 20241211133025.png]]
# [59]
![[Pasted image 20241211133037.png]]
### 3.4 Notes and Comments

# [60]
### 3.5 Exercises
# [61]
![[Pasted image 20241211133114.png]]

# 4 Linear Programming

## Manufacturing with Molds

![[Pasted image 20241211133140.png]]


# [63]

# [94]
# 5 Orthogonal Range Searching

## Querying a Database

![[Pasted image 20241211133300.png]]

# [121]
# 6 Point Location

## Knowing Where You Are

![[Pasted image 20241211133411.png]]

# [147]

# 7 Voronoi Diagrams

## The Post Oﬃce Problem

![[Pasted image 20241211133521.png]]

# [172]

# 8 Arrangements and Duality

Supersampling in Ray Tracing
![[Pasted image 20241211135431.png]]

# [191]

# 9 Delaunay Triangulations

Height Interpolation

![[Pasted image 20241211135535.png]]
![[Pasted image 20241211135544.png]]

# [219]

10 More Geometric Data Structures

Windowing
![[Pasted image 20241211135632.png]]

# [241] 11 Convex Hulls

![[Pasted image 20241211135729.png]]

# [259]
# 12 Binary Space Partitions

The Painter’s Algorithm

# [282]
# 13 Robot Motion Planning

Getting Where You Want to Be

![[Pasted image 20241211135837.png]]

# [307]
# 14 Quadtrees

Non-Uniform Mesh Generation
![[Pasted image 20241211135924.png]]

# [322]
# 15 Visibility Graphs

Finding the Shortest Route

Работы известных художников пользуются популярностью не только среди любителей искусства, но и среди
преступников. Они очень ценны, их легко перевозить, и, по-видимому, не так
сложно продать. Поэтому художественным галереям приходится тщательно охранять свои коллекции.

![[Pasted image 20241211140012.png]]
Днем дежурные могут вести наблюдение, но ночью это должны делать
видеокамеры. Эти камеры обычно подвешиваются к потолку и
вращаются вокруг вертикальной оси. Изображения с камер отправляются на
телевизоры в офисе ночного дежурного. Поскольку легче следить за
несколькими телевизорами, чем за многими, количество камер должно быть
как можно меньше. Дополнительным преимуществом небольшого количества камер является то,
что стоимость системы безопасности будет ниже. С другой стороны, у нас не может быть
слишком мало камер, потому что каждая часть галереи должна быть видна по крайней мере
одной из них. Поэтому мы должны размещать камеры в стратегических позициях,
таким образом, чтобы
каждая из них охраняла большую часть галереи. Это приводит к тому, что обычно
называют «проблемой художественной галереи»: сколько камер нам нужно для охраны
данной галереи и как мы решаем, где их разместить?
# [335]
# 16 Simplex Range Searching

Windowing Revisited

![[Pasted image 20241211140052.png]]